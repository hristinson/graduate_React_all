var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import * as React from 'react';
import { createPopper } from '@popperjs/core';
import is from 'is-lite';
import useTreeChanges from 'tree-changes-hook';
import Floater from './components/Floater';
import Portal from './components/Portal';
import Wrapper from './components/Wrapper';
import { POSITIONING_PROPS, STATUS } from './literals';
import { canUseDOM, enhanceProps, getFallbackPlacements, getModifiers, isFixed, isMobile, log, mergeModifier, once, randomId, } from './modules/helpers';
import { useMount, useSetState, useSingleton, useUnmount, useUpdateEffect } from './modules/hooks';
import getStyles from './modules/styles';
function ReactFloater(props) {
    var _a = enhanceProps(props), autoOpen = _a.autoOpen, callback = _a.callback, children = _a.children, component = _a.component, content = _a.content, debug = _a.debug, disableFlip = _a.disableFlip, disableHoverToClick = _a.disableHoverToClick, event = _a.event, eventDelay = _a.eventDelay, footer = _a.footer, getPopper = _a.getPopper, hideArrow = _a.hideArrow, id = _a.id, modifiers = _a.modifiers, offset = _a.offset, open = _a.open, _b = _a.placement, placement = _b === void 0 ? 'bottom' : _b, portalElement = _a.portalElement, showCloseButton = _a.showCloseButton, style = _a.style, styles = _a.styles, target = _a.target, title = _a.title, wrapperOptions = _a.wrapperOptions;
    var _c = __read(useSetState({
        currentPlacement: placement,
        positionWrapper: !!(wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.position) && !!target,
        status: STATUS.INIT,
        statusWrapper: STATUS.INIT,
    }), 2), state = _c[0], setState = _c[1];
    var arrowRef = React.useRef(null);
    var childRef = React.useRef(null);
    var eventDelayTimer = React.useRef();
    var floaterRef = React.useRef(null);
    var internalId = React.useRef(randomId());
    var isMounted = React.useRef(false);
    var popperRef = React.useRef();
    var stateRef = React.useRef(state);
    var wrapperPopper = React.useRef();
    var wrapperRef = React.useRef(null);
    var wrapperStyles = React.useRef({});
    var currentPlacement = state.currentPlacement, positionWrapper = state.positionWrapper, status = state.status, statusWrapper = state.statusWrapper;
    var changed = useTreeChanges(state).changed;
    var changedProps = useTreeChanges(props).changed;
    var updateState = React.useCallback(function (nextState, callback_) {
        if (isMounted.current) {
            setState(nextState);
            stateRef.current = __assign(__assign({}, state), nextState);
            if (callback_) {
                callback_();
            }
        }
    }, [setState, state]);
    var toggle = React.useCallback(function (forceStatus) {
        var nextStatus = stateRef.current.status === STATUS.OPEN ? STATUS.CLOSING : STATUS.RENDER;
        if (!is.undefined(forceStatus)) {
            nextStatus = forceStatus;
        }
        updateState({
            status: nextStatus,
            statusWrapper: nextStatus === STATUS.CLOSING ? STATUS.RENDER : STATUS.IDLE,
        });
    }, [updateState]);
    var targetElement = React.useRef(function () {
        if (!canUseDOM) {
            return null;
        }
        if (target) {
            if (is.domElement(target)) {
                return target;
            }
            return document.querySelector(target);
        }
        return childRef.current || wrapperRef.current;
    });
    var currentDebug = React.useMemo(function () {
        return canUseDOM && (debug || !!window.ReactFloaterDebug);
    }, [debug]);
    var currentEvent = React.useMemo(function () {
        if (event === 'hover' && isMobile() && !disableHoverToClick) {
            return 'click';
        }
        return event;
    }, [disableHoverToClick, event]);
    var currentStyles = React.useMemo(function () {
        var _a;
        var nextStyles = getStyles(styles);
        var element = targetElement.current();
        if (positionWrapper) {
            var wrapperCurrentStyles = void 0;
            if (status !== STATUS.IDLE) {
                wrapperCurrentStyles = nextStyles.wrapperPosition;
            }
            else if (statusWrapper === STATUS.RENDER) {
                wrapperCurrentStyles = (_a = wrapperPopper.current) === null || _a === void 0 ? void 0 : _a.state.styles;
            }
            nextStyles.wrapper = __assign(__assign({}, nextStyles.wrapper), wrapperCurrentStyles);
        }
        /* istanbul ignore else */
        if (element) {
            var targetStyles_1 = window.getComputedStyle(element);
            /* istanbul ignore else */
            if (wrapperStyles.current) {
                nextStyles.wrapper = __assign(__assign({}, nextStyles.wrapper), wrapperStyles.current);
            }
            else if (!['relative', 'static'].includes(targetStyles_1.position)) {
                wrapperStyles.current = {};
                if (!positionWrapper) {
                    POSITIONING_PROPS.forEach(function (d) {
                        if (d === 'position') {
                            wrapperStyles.current[d] = targetStyles_1[d];
                        }
                        else {
                            wrapperStyles.current[d] = targetStyles_1[d];
                        }
                    });
                    nextStyles.wrapper = __assign(__assign({}, nextStyles.wrapper), wrapperStyles.current);
                }
            }
        }
        return nextStyles;
    }, [positionWrapper, status, statusWrapper, styles]);
    var cleanUp = React.useRef(function () {
        if (popperRef.current) {
            popperRef.current.destroy();
            popperRef.current = undefined;
        }
        if (wrapperPopper.current) {
            wrapperPopper.current.destroy();
            wrapperPopper.current = undefined;
        }
    });
    var initPopper = React.useRef(function () {
        var nextStatus = stateRef.current.status === STATUS.RENDER ? STATUS.OPENING : STATUS.IDLE;
        var element = targetElement.current();
        /* istanbul ignore else */
        if (placement === 'center') {
            setTimeout(function () {
                updateState({ status: nextStatus });
            }, 100);
        }
        else if (element) {
            if (floaterRef.current) {
                var _a = getModifiers(modifiers), arrow = _a.arrow, flip = _a.flip, offsetModifier = _a.offset, rest = __rest(_a, ["arrow", "flip", "offset"]);
                popperRef.current = createPopper(element, floaterRef.current, {
                    placement: placement,
                    strategy: isFixed(childRef.current) ? 'fixed' : 'absolute',
                    modifiers: __spreadArray([
                        mergeModifier({
                            name: 'arrow',
                            enabled: !hideArrow,
                            options: {
                                element: arrowRef.current,
                                padding: 8,
                            },
                        }, arrow),
                        mergeModifier({
                            name: 'flip',
                            enabled: !disableFlip,
                            options: {
                                altAxis: false,
                                fallbackPlacements: getFallbackPlacements(placement || 'bottom'),
                            },
                        }, flip),
                        mergeModifier({
                            name: 'offset',
                            enabled: true,
                            options: {
                                offset: [0, offset],
                            },
                        }, offsetModifier),
                        {
                            name: 'updatePlacement',
                            enabled: true,
                            phase: 'afterWrite',
                            fn: function (_a) {
                                var instance = _a.instance, popperState = _a.state;
                                if (popperState.placement !== stateRef.current.currentPlacement) {
                                    popperRef.current = instance;
                                    updateState({ currentPlacement: popperState.placement });
                                }
                            },
                        },
                        {
                            name: 'applyArrowStyle',
                            enabled: true,
                            phase: 'write',
                            fn: function (_a) {
                                var popperState = _a.state;
                                var stateArrow = popperState.elements.arrow, statePlacement = popperState.placement;
                                if (stateArrow) {
                                    if (statePlacement.startsWith('top')) {
                                        stateArrow.style.bottom = '0px';
                                        stateArrow.style.right = '';
                                    }
                                    else if (statePlacement.startsWith('bottom')) {
                                        stateArrow.style.top = '0px';
                                        stateArrow.style.right = '';
                                    }
                                    else if (statePlacement.startsWith('left')) {
                                        stateArrow.style.right = '0px';
                                        stateArrow.style.bottom = '';
                                    }
                                    else if (statePlacement.startsWith('right')) {
                                        stateArrow.style.left = '0px';
                                        stateArrow.style.bottom = '';
                                    }
                                }
                            },
                        }
                    ], __read(Object.values(rest)), false),
                    onFirstUpdate: function (popperState) {
                        updateState({
                            currentPlacement: popperState.placement,
                            status: nextStatus,
                        });
                        if (placement !== popperState.placement) {
                            setTimeout(function () {
                                var _a;
                                (_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.forceUpdate();
                            });
                        }
                    },
                });
                if (getPopper && popperRef.current) {
                    getPopper(popperRef.current, 'floater');
                }
            }
            else {
                updateState({
                    status: STATUS.IDLE,
                });
            }
        }
        if (element &&
            !wrapperPopper.current &&
            stateRef.current.positionWrapper &&
            wrapperRef.current &&
            placement !== 'center') {
            var wrapperOffset = (wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.offset) ? wrapperOptions.offset : 0;
            wrapperPopper.current = createPopper(element, wrapperRef.current, {
                placement: (wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.placement) || placement,
                modifiers: [
                    {
                        name: 'arrow',
                        enabled: false,
                    },
                    {
                        name: 'offset',
                        options: {
                            offset: [0, wrapperOffset],
                        },
                    },
                    {
                        name: 'flip',
                        enabled: false,
                    },
                ],
                onFirstUpdate: function (popperState) {
                    updateState({ statusWrapper: STATUS.RENDER });
                    if (placement !== popperState.placement) {
                        setTimeout(function () {
                            var _a;
                            (_a = wrapperPopper.current) === null || _a === void 0 ? void 0 : _a.forceUpdate();
                        });
                    }
                },
            });
            if (getPopper) {
                getPopper(wrapperPopper.current, 'wrapper');
            }
        }
    });
    var handleLoad = React.useRef(function () {
        if (popperRef.current) {
            popperRef.current.forceUpdate();
        }
        if (wrapperPopper.current) {
            wrapperPopper.current.forceUpdate();
        }
    });
    var handleTransitionEnd = React.useRef(function () {
        /* istanbul ignore else */
        if (wrapperPopper.current) {
            wrapperPopper.current.forceUpdate();
        }
        updateState({
            status: stateRef.current.status === STATUS.OPENING ? STATUS.OPEN : STATUS.IDLE,
        }, function () {
            if (callback) {
                callback(stateRef.current.status === STATUS.OPEN ? 'open' : 'close', enhanceProps(props));
            }
        });
    });
    var handleClick = React.useCallback(function () {
        if (is.boolean(open)) {
            return;
        }
        /* istanbul ignore else */
        if (currentEvent === 'click' || (currentEvent === 'hover' && positionWrapper)) {
            log({
                title: 'click',
                data: [{ event: event, status: status === STATUS.OPEN ? 'closing' : 'opening' }],
                debug: currentDebug,
            });
            toggle(status === 'idle' ? STATUS.RENDER : undefined);
        }
    }, [currentDebug, currentEvent, event, open, positionWrapper, status, toggle]);
    var handleMouseEnter = React.useCallback(function () {
        if (is.boolean(open) || isMobile() || currentEvent !== 'hover') {
            return;
        }
        log({
            title: 'mouseEnter',
            data: [{ key: 'originalEvent', value: event }],
            debug: currentDebug,
        });
        if (status === STATUS.IDLE) {
            clearTimeout(eventDelayTimer.current);
            eventDelayTimer.current = undefined;
            toggle(STATUS.RENDER);
        }
    }, [currentDebug, currentEvent, event, open, status, toggle]);
    var handleMouseLeave = React.useCallback(function () {
        if (is.boolean(open) || isMobile()) {
            return;
        }
        /* istanbul ignore else */
        if (currentEvent === 'hover') {
            log({
                title: 'mouseLeave',
                data: [{ key: 'originalEvent', value: event }],
                debug: currentDebug,
            });
            var hasOpenStatus = [STATUS.OPENING, STATUS.OPEN].includes(status);
            if (!eventDelay) {
                toggle(status === STATUS.CLOSING ? STATUS.IDLE : STATUS.CLOSING);
            }
            else if (!positionWrapper) {
                if (hasOpenStatus) {
                    clearTimeout(eventDelayTimer.current);
                    eventDelayTimer.current = window.setTimeout(function () {
                        toggle();
                        eventDelayTimer.current = undefined;
                    }, eventDelay * 1000);
                }
            }
        }
    }, [currentDebug, currentEvent, event, eventDelay, open, positionWrapper, status, toggle]);
    useSingleton(function () {
        if (canUseDOM) {
            window.addEventListener('load', handleLoad.current);
        }
    });
    useMount(function () {
        isMounted.current = true;
        log({
            title: 'init',
            data: {
                hasChildren: !!children,
                hasTarget: !!target,
                isControlled: is.boolean(open),
                positionWrapper: positionWrapper,
                target: targetElement.current(),
                floater: floaterRef.current,
            },
            debug: currentDebug,
        });
        initPopper.current();
    });
    useUnmount(function () {
        isMounted.current = false;
        cleanUp.current();
        window.removeEventListener('load', handleLoad.current);
    });
    // handle changes
    useUpdateEffect(function () {
        if (!canUseDOM) {
            return;
        }
        if (changedProps('open')) {
            var forceStatus = void 0;
            // always follow `open` in controlled mode
            if (is.boolean(open)) {
                forceStatus = open ? STATUS.RENDER : STATUS.CLOSING;
            }
            toggle(forceStatus);
        }
        if (changedProps('wrapperOptions.position') || changedProps('target')) {
            updateState({
                positionWrapper: !!(wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.position) && !!target,
            });
        }
        if ((changed('status', STATUS.IDLE) && open) ||
            (changed('status', STATUS.IDLE, STATUS.INIT) && autoOpen)) {
            toggle(STATUS.RENDER);
        }
        if (changed('status', STATUS.RENDER)) {
            if (popperRef.current) {
                popperRef.current.destroy();
            }
            initPopper.current();
        }
        if (floaterRef.current && changed('status', [STATUS.RENDER, STATUS.CLOSING])) {
            once(floaterRef.current, 'transitionend', handleTransitionEnd.current);
        }
        if (changed('status', STATUS.IDLE, STATUS.CLOSING) && popperRef.current) {
            popperRef.current.destroy();
            popperRef.current = undefined;
            if (wrapperPopper.current) {
                wrapperPopper.current.forceUpdate();
            }
        }
    });
    var wrapper = (_jsx(Wrapper, __assign({ childRef: childRef, id: id || internalId.current, isControlled: is.boolean(open), onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, status: status, style: style, styles: currentStyles.wrapper, wrapperRef: wrapperRef }, { children: children })));
    return (_jsxs(_Fragment, { children: [_jsxs(Portal, __assign({ hasChildren: !!children, placement: currentPlacement, portalElement: portalElement, target: target, zIndex: currentStyles.options.zIndex }, { children: [_jsx(Floater, { arrowRef: arrowRef, component: component, content: content, floaterRef: floaterRef, footer: footer, hideArrow: hideArrow || currentPlacement === 'center', id: id || internalId.current, onClick: handleClick, placement: currentPlacement, positionWrapper: positionWrapper, showCloseButton: showCloseButton, status: status, styles: currentStyles, title: title }), positionWrapper && wrapper] })), !positionWrapper && wrapper] }));
}
ReactFloater.defaultProps = {
    autoOpen: false,
    debug: false,
    disableFlip: false,
    disableHoverToClick: false,
    event: 'click',
    eventDelay: 0.4,
    hideArrow: false,
    offset: 15,
    placement: 'bottom',
    showCloseButton: false,
};
export default ReactFloater;
//# sourceMappingURL=index.js.map