"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
var jsx_runtime_1 = require("react/jsx-runtime");
var React = require("react");
var core_1 = require("@popperjs/core");
var is_lite_1 = require("is-lite");
var tree_changes_hook_1 = require("tree-changes-hook");
var Floater_1 = require("./components/Floater");
var Portal_1 = require("./components/Portal");
var Wrapper_1 = require("./components/Wrapper");
var literals_1 = require("./literals");
var helpers_1 = require("./modules/helpers");
var hooks_1 = require("./modules/hooks");
var styles_1 = require("./modules/styles");
function ReactFloater(props) {
    var _a = (0, helpers_1.enhanceProps)(props), autoOpen = _a.autoOpen, callback = _a.callback, children = _a.children, component = _a.component, content = _a.content, debug = _a.debug, disableFlip = _a.disableFlip, disableHoverToClick = _a.disableHoverToClick, event = _a.event, eventDelay = _a.eventDelay, footer = _a.footer, getPopper = _a.getPopper, hideArrow = _a.hideArrow, id = _a.id, modifiers = _a.modifiers, offset = _a.offset, open = _a.open, _b = _a.placement, placement = _b === void 0 ? 'bottom' : _b, portalElement = _a.portalElement, showCloseButton = _a.showCloseButton, style = _a.style, styles = _a.styles, target = _a.target, title = _a.title, wrapperOptions = _a.wrapperOptions;
    var _c = __read((0, hooks_1.useSetState)({
        currentPlacement: placement,
        positionWrapper: !!(wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.position) && !!target,
        status: literals_1.STATUS.INIT,
        statusWrapper: literals_1.STATUS.INIT,
    }), 2), state = _c[0], setState = _c[1];
    var arrowRef = React.useRef(null);
    var childRef = React.useRef(null);
    var eventDelayTimer = React.useRef();
    var floaterRef = React.useRef(null);
    var internalId = React.useRef((0, helpers_1.randomId)());
    var isMounted = React.useRef(false);
    var popperRef = React.useRef();
    var stateRef = React.useRef(state);
    var wrapperPopper = React.useRef();
    var wrapperRef = React.useRef(null);
    var wrapperStyles = React.useRef({});
    var currentPlacement = state.currentPlacement, positionWrapper = state.positionWrapper, status = state.status, statusWrapper = state.statusWrapper;
    var changed = (0, tree_changes_hook_1.default)(state).changed;
    var changedProps = (0, tree_changes_hook_1.default)(props).changed;
    var updateState = React.useCallback(function (nextState, callback_) {
        if (isMounted.current) {
            setState(nextState);
            stateRef.current = __assign(__assign({}, state), nextState);
            if (callback_) {
                callback_();
            }
        }
    }, [setState, state]);
    var toggle = React.useCallback(function (forceStatus) {
        var nextStatus = stateRef.current.status === literals_1.STATUS.OPEN ? literals_1.STATUS.CLOSING : literals_1.STATUS.RENDER;
        if (!is_lite_1.default.undefined(forceStatus)) {
            nextStatus = forceStatus;
        }
        updateState({
            status: nextStatus,
            statusWrapper: nextStatus === literals_1.STATUS.CLOSING ? literals_1.STATUS.RENDER : literals_1.STATUS.IDLE,
        });
    }, [updateState]);
    var targetElement = React.useRef(function () {
        if (!helpers_1.canUseDOM) {
            return null;
        }
        if (target) {
            if (is_lite_1.default.domElement(target)) {
                return target;
            }
            return document.querySelector(target);
        }
        return childRef.current || wrapperRef.current;
    });
    var currentDebug = React.useMemo(function () {
        return helpers_1.canUseDOM && (debug || !!window.ReactFloaterDebug);
    }, [debug]);
    var currentEvent = React.useMemo(function () {
        if (event === 'hover' && (0, helpers_1.isMobile)() && !disableHoverToClick) {
            return 'click';
        }
        return event;
    }, [disableHoverToClick, event]);
    var currentStyles = React.useMemo(function () {
        var _a;
        var nextStyles = (0, styles_1.default)(styles);
        var element = targetElement.current();
        if (positionWrapper) {
            var wrapperCurrentStyles = void 0;
            if (status !== literals_1.STATUS.IDLE) {
                wrapperCurrentStyles = nextStyles.wrapperPosition;
            }
            else if (statusWrapper === literals_1.STATUS.RENDER) {
                wrapperCurrentStyles = (_a = wrapperPopper.current) === null || _a === void 0 ? void 0 : _a.state.styles;
            }
            nextStyles.wrapper = __assign(__assign({}, nextStyles.wrapper), wrapperCurrentStyles);
        }
        /* istanbul ignore else */
        if (element) {
            var targetStyles_1 = window.getComputedStyle(element);
            /* istanbul ignore else */
            if (wrapperStyles.current) {
                nextStyles.wrapper = __assign(__assign({}, nextStyles.wrapper), wrapperStyles.current);
            }
            else if (!['relative', 'static'].includes(targetStyles_1.position)) {
                wrapperStyles.current = {};
                if (!positionWrapper) {
                    literals_1.POSITIONING_PROPS.forEach(function (d) {
                        if (d === 'position') {
                            wrapperStyles.current[d] = targetStyles_1[d];
                        }
                        else {
                            wrapperStyles.current[d] = targetStyles_1[d];
                        }
                    });
                    nextStyles.wrapper = __assign(__assign({}, nextStyles.wrapper), wrapperStyles.current);
                }
            }
        }
        return nextStyles;
    }, [positionWrapper, status, statusWrapper, styles]);
    var cleanUp = React.useRef(function () {
        if (popperRef.current) {
            popperRef.current.destroy();
            popperRef.current = undefined;
        }
        if (wrapperPopper.current) {
            wrapperPopper.current.destroy();
            wrapperPopper.current = undefined;
        }
    });
    var initPopper = React.useRef(function () {
        var nextStatus = stateRef.current.status === literals_1.STATUS.RENDER ? literals_1.STATUS.OPENING : literals_1.STATUS.IDLE;
        var element = targetElement.current();
        /* istanbul ignore else */
        if (placement === 'center') {
            setTimeout(function () {
                updateState({ status: nextStatus });
            }, 100);
        }
        else if (element) {
            if (floaterRef.current) {
                var _a = (0, helpers_1.getModifiers)(modifiers), arrow = _a.arrow, flip = _a.flip, offsetModifier = _a.offset, rest = __rest(_a, ["arrow", "flip", "offset"]);
                popperRef.current = (0, core_1.createPopper)(element, floaterRef.current, {
                    placement: placement,
                    strategy: (0, helpers_1.isFixed)(childRef.current) ? 'fixed' : 'absolute',
                    modifiers: __spreadArray([
                        (0, helpers_1.mergeModifier)({
                            name: 'arrow',
                            enabled: !hideArrow,
                            options: {
                                element: arrowRef.current,
                                padding: 8,
                            },
                        }, arrow),
                        (0, helpers_1.mergeModifier)({
                            name: 'flip',
                            enabled: !disableFlip,
                            options: {
                                altAxis: false,
                                fallbackPlacements: (0, helpers_1.getFallbackPlacements)(placement || 'bottom'),
                            },
                        }, flip),
                        (0, helpers_1.mergeModifier)({
                            name: 'offset',
                            enabled: true,
                            options: {
                                offset: [0, offset],
                            },
                        }, offsetModifier),
                        {
                            name: 'updatePlacement',
                            enabled: true,
                            phase: 'afterWrite',
                            fn: function (_a) {
                                var instance = _a.instance, popperState = _a.state;
                                if (popperState.placement !== stateRef.current.currentPlacement) {
                                    popperRef.current = instance;
                                    updateState({ currentPlacement: popperState.placement });
                                }
                            },
                        },
                        {
                            name: 'applyArrowStyle',
                            enabled: true,
                            phase: 'write',
                            fn: function (_a) {
                                var popperState = _a.state;
                                var stateArrow = popperState.elements.arrow, statePlacement = popperState.placement;
                                if (stateArrow) {
                                    if (statePlacement.startsWith('top')) {
                                        stateArrow.style.bottom = '0px';
                                        stateArrow.style.right = '';
                                    }
                                    else if (statePlacement.startsWith('bottom')) {
                                        stateArrow.style.top = '0px';
                                        stateArrow.style.right = '';
                                    }
                                    else if (statePlacement.startsWith('left')) {
                                        stateArrow.style.right = '0px';
                                        stateArrow.style.bottom = '';
                                    }
                                    else if (statePlacement.startsWith('right')) {
                                        stateArrow.style.left = '0px';
                                        stateArrow.style.bottom = '';
                                    }
                                }
                            },
                        }
                    ], __read(Object.values(rest)), false),
                    onFirstUpdate: function (popperState) {
                        updateState({
                            currentPlacement: popperState.placement,
                            status: nextStatus,
                        });
                        if (placement !== popperState.placement) {
                            setTimeout(function () {
                                var _a;
                                (_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.forceUpdate();
                            });
                        }
                    },
                });
                if (getPopper && popperRef.current) {
                    getPopper(popperRef.current, 'floater');
                }
            }
            else {
                updateState({
                    status: literals_1.STATUS.IDLE,
                });
            }
        }
        if (element &&
            !wrapperPopper.current &&
            stateRef.current.positionWrapper &&
            wrapperRef.current &&
            placement !== 'center') {
            var wrapperOffset = (wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.offset) ? wrapperOptions.offset : 0;
            wrapperPopper.current = (0, core_1.createPopper)(element, wrapperRef.current, {
                placement: (wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.placement) || placement,
                modifiers: [
                    {
                        name: 'arrow',
                        enabled: false,
                    },
                    {
                        name: 'offset',
                        options: {
                            offset: [0, wrapperOffset],
                        },
                    },
                    {
                        name: 'flip',
                        enabled: false,
                    },
                ],
                onFirstUpdate: function (popperState) {
                    updateState({ statusWrapper: literals_1.STATUS.RENDER });
                    if (placement !== popperState.placement) {
                        setTimeout(function () {
                            var _a;
                            (_a = wrapperPopper.current) === null || _a === void 0 ? void 0 : _a.forceUpdate();
                        });
                    }
                },
            });
            if (getPopper) {
                getPopper(wrapperPopper.current, 'wrapper');
            }
        }
    });
    var handleLoad = React.useRef(function () {
        if (popperRef.current) {
            popperRef.current.forceUpdate();
        }
        if (wrapperPopper.current) {
            wrapperPopper.current.forceUpdate();
        }
    });
    var handleTransitionEnd = React.useRef(function () {
        /* istanbul ignore else */
        if (wrapperPopper.current) {
            wrapperPopper.current.forceUpdate();
        }
        updateState({
            status: stateRef.current.status === literals_1.STATUS.OPENING ? literals_1.STATUS.OPEN : literals_1.STATUS.IDLE,
        }, function () {
            if (callback) {
                callback(stateRef.current.status === literals_1.STATUS.OPEN ? 'open' : 'close', (0, helpers_1.enhanceProps)(props));
            }
        });
    });
    var handleClick = React.useCallback(function () {
        if (is_lite_1.default.boolean(open)) {
            return;
        }
        /* istanbul ignore else */
        if (currentEvent === 'click' || (currentEvent === 'hover' && positionWrapper)) {
            (0, helpers_1.log)({
                title: 'click',
                data: [{ event: event, status: status === literals_1.STATUS.OPEN ? 'closing' : 'opening' }],
                debug: currentDebug,
            });
            toggle(status === 'idle' ? literals_1.STATUS.RENDER : undefined);
        }
    }, [currentDebug, currentEvent, event, open, positionWrapper, status, toggle]);
    var handleMouseEnter = React.useCallback(function () {
        if (is_lite_1.default.boolean(open) || (0, helpers_1.isMobile)() || currentEvent !== 'hover') {
            return;
        }
        (0, helpers_1.log)({
            title: 'mouseEnter',
            data: [{ key: 'originalEvent', value: event }],
            debug: currentDebug,
        });
        if (status === literals_1.STATUS.IDLE) {
            clearTimeout(eventDelayTimer.current);
            eventDelayTimer.current = undefined;
            toggle(literals_1.STATUS.RENDER);
        }
    }, [currentDebug, currentEvent, event, open, status, toggle]);
    var handleMouseLeave = React.useCallback(function () {
        if (is_lite_1.default.boolean(open) || (0, helpers_1.isMobile)()) {
            return;
        }
        /* istanbul ignore else */
        if (currentEvent === 'hover') {
            (0, helpers_1.log)({
                title: 'mouseLeave',
                data: [{ key: 'originalEvent', value: event }],
                debug: currentDebug,
            });
            var hasOpenStatus = [literals_1.STATUS.OPENING, literals_1.STATUS.OPEN].includes(status);
            if (!eventDelay) {
                toggle(status === literals_1.STATUS.CLOSING ? literals_1.STATUS.IDLE : literals_1.STATUS.CLOSING);
            }
            else if (!positionWrapper) {
                if (hasOpenStatus) {
                    clearTimeout(eventDelayTimer.current);
                    eventDelayTimer.current = window.setTimeout(function () {
                        toggle();
                        eventDelayTimer.current = undefined;
                    }, eventDelay * 1000);
                }
            }
        }
    }, [currentDebug, currentEvent, event, eventDelay, open, positionWrapper, status, toggle]);
    (0, hooks_1.useSingleton)(function () {
        if (helpers_1.canUseDOM) {
            window.addEventListener('load', handleLoad.current);
        }
    });
    (0, hooks_1.useMount)(function () {
        isMounted.current = true;
        (0, helpers_1.log)({
            title: 'init',
            data: {
                hasChildren: !!children,
                hasTarget: !!target,
                isControlled: is_lite_1.default.boolean(open),
                positionWrapper: positionWrapper,
                target: targetElement.current(),
                floater: floaterRef.current,
            },
            debug: currentDebug,
        });
        initPopper.current();
    });
    (0, hooks_1.useUnmount)(function () {
        isMounted.current = false;
        cleanUp.current();
        window.removeEventListener('load', handleLoad.current);
    });
    // handle changes
    (0, hooks_1.useUpdateEffect)(function () {
        if (!helpers_1.canUseDOM) {
            return;
        }
        if (changedProps('open')) {
            var forceStatus = void 0;
            // always follow `open` in controlled mode
            if (is_lite_1.default.boolean(open)) {
                forceStatus = open ? literals_1.STATUS.RENDER : literals_1.STATUS.CLOSING;
            }
            toggle(forceStatus);
        }
        if (changedProps('wrapperOptions.position') || changedProps('target')) {
            updateState({
                positionWrapper: !!(wrapperOptions === null || wrapperOptions === void 0 ? void 0 : wrapperOptions.position) && !!target,
            });
        }
        if ((changed('status', literals_1.STATUS.IDLE) && open) ||
            (changed('status', literals_1.STATUS.IDLE, literals_1.STATUS.INIT) && autoOpen)) {
            toggle(literals_1.STATUS.RENDER);
        }
        if (changed('status', literals_1.STATUS.RENDER)) {
            if (popperRef.current) {
                popperRef.current.destroy();
            }
            initPopper.current();
        }
        if (floaterRef.current && changed('status', [literals_1.STATUS.RENDER, literals_1.STATUS.CLOSING])) {
            (0, helpers_1.once)(floaterRef.current, 'transitionend', handleTransitionEnd.current);
        }
        if (changed('status', literals_1.STATUS.IDLE, literals_1.STATUS.CLOSING) && popperRef.current) {
            popperRef.current.destroy();
            popperRef.current = undefined;
            if (wrapperPopper.current) {
                wrapperPopper.current.forceUpdate();
            }
        }
    });
    var wrapper = ((0, jsx_runtime_1.jsx)(Wrapper_1.default, __assign({ childRef: childRef, id: id || internalId.current, isControlled: is_lite_1.default.boolean(open), onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, status: status, style: style, styles: currentStyles.wrapper, wrapperRef: wrapperRef }, { children: children })));
    return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(Portal_1.default, __assign({ hasChildren: !!children, placement: currentPlacement, portalElement: portalElement, target: target, zIndex: currentStyles.options.zIndex }, { children: [(0, jsx_runtime_1.jsx)(Floater_1.default, { arrowRef: arrowRef, component: component, content: content, floaterRef: floaterRef, footer: footer, hideArrow: hideArrow || currentPlacement === 'center', id: id || internalId.current, onClick: handleClick, placement: currentPlacement, positionWrapper: positionWrapper, showCloseButton: showCloseButton, status: status, styles: currentStyles, title: title }), positionWrapper && wrapper] })), !positionWrapper && wrapper] }));
}
ReactFloater.defaultProps = {
    autoOpen: false,
    debug: false,
    disableFlip: false,
    disableHoverToClick: false,
    event: 'click',
    eventDelay: 0.4,
    hideArrow: false,
    offset: 15,
    placement: 'bottom',
    showCloseButton: false,
};
exports.default = ReactFloater;
//# sourceMappingURL=index.js.map