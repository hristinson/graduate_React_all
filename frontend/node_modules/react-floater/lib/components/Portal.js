"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var react_dom_1 = require("react-dom");
var is_lite_1 = require("is-lite");
var helpers_1 = require("../modules/helpers");
var hooks_1 = require("../modules/hooks");
function ReactFloaterPortal(props) {
    var children = props.children, hasChildren = props.hasChildren, placement = props.placement, portalElement = props.portalElement, target = props.target, zIndex = props.zIndex;
    var node = React.useRef(null);
    var initialize = React.useCallback(function () {
        if (!helpers_1.canUseDOM) {
            return;
        }
        if (portalElement) {
            node.current = is_lite_1.default.string(portalElement)
                ? document.querySelector(portalElement)
                : portalElement;
        }
        if (!portalElement || !node.current) {
            var portal = document.getElementById('react-floater-portal');
            if (portal) {
                node.current = portal;
            }
            else {
                node.current = document.createElement('div');
                node.current.id = helpers_1.portalId;
                node.current.style.zIndex = "".concat(zIndex);
                document.body.appendChild(node.current);
            }
        }
    }, [portalElement, zIndex]);
    (0, hooks_1.useSingleton)(initialize);
    (0, hooks_1.useMount)(function () {
        if (!portalElement && !document.getElementById(helpers_1.portalId)) {
            if (node.current) {
                document.body.appendChild(node.current);
            }
            else {
                initialize();
            }
        }
    });
    (0, hooks_1.useUnmount)(function () {
        if (!helpers_1.canUseDOM || !node.current) {
            return;
        }
        try {
            if (node.current.id === helpers_1.portalId && node.current.childElementCount === 0) {
                if (document.body.contains(node.current)) {
                    document.body.removeChild(node.current);
                    node.current = null;
                }
            }
        }
        catch (_a) {
            node.current = null;
        }
    });
    if (node.current) {
        if (!hasChildren && !target && placement !== 'center') {
            return null;
        }
        return (0, react_dom_1.createPortal)(children, node.current);
    }
    return null;
}
exports.default = ReactFloaterPortal;
//# sourceMappingURL=Portal.js.map