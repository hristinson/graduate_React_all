import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import { useMount, usePrevious, useUnmount, useUpdateEffect } from 'react-use';
import { css, keyframes, useTheme } from '@emotion/react';
import styled from '@emotion/styled';
import is from 'is-lite';
import { Icon } from './Icon';
import { baseStyles, buttonStyles } from './modules/system';
import { black } from './modules/theme';
function getPortalElement() {
    return document.querySelector('.__portal');
}
function createPortalElement() {
    const newElement = document.createElement('div');
    newElement.classList.add('__portal');
    return newElement;
}
const portalHide = keyframes `
  0% {
    opacity: 1;
    visibility: visible;
  }

  100% {
    opacity: 0;
    visibility: hidden;
  }
`;
const portalShow = keyframes `
  0% {
    opacity: 0;
    visibility: hidden;
  }

  100% {
    opacity: 1;
    visibility: visible;
  }
`;
const CloseButton = styled.button `
  ${baseStyles};
  ${buttonStyles};
  align-items: center;
  color: ${black};
  display: inline-flex;
  height: 30px;
  justify-content: center;
  line-height: 1;
  pointer-events: all;
  position: absolute;
  right: 0;
  top: 0;
  width: 30px;
  z-index: 20;
`;
const Content = styled.div `
  max-height: 100%;
  position: relative;
  width: auto;
  z-index: 10;
`;
const Overlay = styled.div(props => {
    const { darkMode, isActive } = props;
    return css `
    background-color: ${darkMode ? 'rgba(222, 222, 222, 0.3)' : 'rgba(0, 0, 0, 0.3)'};
    bottom: 0;
    left: 0;
    opacity: ${isActive ? 1 : 0};
    position: absolute;
    right: 0;
    top: 0;
    transition: opacity 0.5s;
  `;
});
const StyledPortal = styled.div(props => {
    const { isActive, zIndex } = props;
    return css `
    align-items: center;
    animation-duration: 0.5s;
    animation-name: ${portalHide};
    animation-play-state: ${isActive ? 'running' : 'paused'};
    animation-name: ${isActive ? portalShow : portalHide};
    animation-direction: ${isActive ? 'normal' : 'reverse'};
    bottom: 0;
    display: flex;
    justify-content: center;
    left: 0;
    position: fixed;
    right: 0;
    top: 0;
    z-index: ${zIndex};
  `;
});
export function Portal(props) {
    const { children, closeOnClickOverlay, closeOnEsc, hideOverlay, isActive, onClose, onOpen, showCloseButton, zIndex = 1000, } = props;
    const [isReady, setReady] = useState(false);
    const portal = useRef(null);
    const { darkMode = false } = useTheme();
    const closePortal = useRef(() => {
        destroyPortal.current();
        if (is.function(onClose)) {
            onClose();
        }
    });
    const destroyPortal = useRef(() => {
        if (closeOnEsc) {
            document.removeEventListener('keydown', handleKeyDown);
        }
    });
    const previousIsActive = usePrevious(isActive);
    const previousCloseOnEsc = usePrevious(closeOnEsc);
    const handleKeyDown = useCallback(event => {
        if (event.keyCode === 27) {
            event.stopPropagation();
            closePortal.current();
        }
    }, []);
    useMount(() => {
        let element = getPortalElement();
        if (!getPortalElement()) {
            element = createPortalElement();
            document.body.appendChild(element);
        }
        portal.current = element;
        setReady(true);
        if (isActive && closeOnEsc) {
            document.addEventListener('keydown', handleKeyDown);
        }
    });
    useUnmount(() => {
        destroyPortal.current();
    });
    const openPortal = useCallback(() => {
        if (is.function(onOpen)) {
            onOpen();
        }
        if (closeOnEsc) {
            document.addEventListener('keydown', handleKeyDown);
        }
    }, [closeOnEsc, handleKeyDown, onOpen]);
    useUpdateEffect(() => {
        const hasChanged = previousIsActive !== isActive;
        if (hasChanged && isActive) {
            openPortal();
        }
        else if (hasChanged && !isActive) {
            destroyPortal.current();
        }
        if (previousCloseOnEsc !== closeOnEsc) {
            if (closeOnEsc) {
                document.addEventListener('keydown', handleKeyDown);
            }
            else {
                document.removeEventListener('keydown', handleKeyDown);
            }
        }
    }, [
        closeOnEsc,
        destroyPortal,
        handleKeyDown,
        isActive,
        openPortal,
        previousIsActive,
        previousCloseOnEsc,
    ]);
    const handleClickClose = useCallback(() => {
        if (!closeOnClickOverlay) {
            return;
        }
        closePortal.current();
    }, [closeOnClickOverlay, closePortal]);
    const content = [];
    if (isActive) {
        content.push(children);
    }
    if (!isReady || !portal.current) {
        return null;
    }
    return createPortal(_jsxs(StyledPortal, { "data-component-name": "Portal", isActive: isActive, zIndex: zIndex, children: [!hideOverlay && (_jsx(Overlay, { darkMode: darkMode, "data-component-name": "PortalOverlay", isActive: isActive, onClick: handleClickClose })), showCloseButton && (_jsx(CloseButton, { onClick: handleClickClose, title: "Close", type: "button", children: _jsx(Icon, { name: "close-o", size: 20, title: "Close" }) })), _jsx(Content, { "data-component-name": "PortalContent", children: content })] }), portal.current);
}
Portal.defaultProps = {
    closeOnClickOverlay: true,
    closeOnEsc: true,
    hideOverlay: false,
    isActive: false,
    showCloseButton: false,
    zIndex: 1000,
};
//# sourceMappingURL=Portal.js.map