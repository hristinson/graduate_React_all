import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useRef } from 'react';
import { css } from '@emotion/react';
import styled from '@emotion/styled';
import Add from './Add';
import { BoxInline } from '../Box';
import { getColorVariant, getTheme } from '../modules/helpers';
import { getStyledOptions, isDarkMode } from '../modules/system';
const getSharedStyles = (spacing) => css `
  align-items: center;
  display: flex;
  padding: ${spacing.xs} ${spacing.sm};
  width: 100%;
`;
const Centered = styled('div', getStyledOptions())(props => {
    const { withBorder } = props;
    const { grayLight, spacing } = getTheme(props);
    return css `
    ${getSharedStyles(spacing)};
    border-top: ${withBorder ? `1px solid ${grayLight}` : 0};
    justify-content: center;
    padding: 0;
  `;
});
const Empty = styled('div', getStyledOptions())(props => {
    const { spacing } = getTheme(props);
    return css `
    ${getSharedStyles(spacing)};
    justify-content: center;
  `;
});
const Input = styled('input', getStyledOptions())(props => {
    const { shade, variant = 'primary' } = props;
    const { radius, variants } = getTheme(props);
    const { bg } = getColorVariant(variant, shade, variants);
    return css `
    border-radius: ${radius.xs};

    :focus {
      filter: drop-shadow(0 0 2px ${bg});
      outline: none;
    }
  `;
});
const Item = styled('div', getStyledOptions())(props => {
    const { disabled, hovered, selected, shade, variant = 'primary' } = props;
    const { darkMode, grayDark, grayDarker, grayLight, grayLighter, grayLightest, grayMid, spacing, variants, white, } = getTheme(props);
    const { bg, color } = getColorVariant(variant, shade, variants);
    const { bg: bgHoverLight, color: colorHoverLight } = getColorVariant(variant, 'lightest', variants);
    const { bg: bgHoverDark, color: colorHoverDark } = getColorVariant(variant, 'darker', variants);
    let itemBgColor = darkMode ? grayDarker : white;
    let itemColor = darkMode ? grayLighter : grayDarker;
    const bgHover = darkMode ? bgHoverDark : bgHoverLight;
    const colorHover = darkMode ? colorHoverDark : colorHoverLight;
    if (disabled) {
        itemBgColor = darkMode ? grayDark : grayLightest;
        itemColor = darkMode ? grayLight : grayMid;
    }
    return css `
    ${getSharedStyles(spacing)};
    background-color: ${itemBgColor};
    color: ${itemColor};
    cursor: pointer;
    pointer-events: ${disabled ? 'none' : undefined};
    ${selected &&
        css `
      background-color: ${bg};
      color: ${color};
    `};
    ${hovered &&
        !disabled &&
        css `
      background-color: ${bgHover};
      color: ${colorHover};
    `};

    &:hover {
      background-color: ${bgHover};
      color: ${colorHover};
    }
  `;
});
const List = styled('div', getStyledOptions())(props => {
    const { maxHeight } = props;
    const { grayDark, grayDarker, grayLight, white } = getTheme(props);
    const darkMode = isDarkMode(props);
    return css `
    background-color: ${darkMode ? grayDarker : white};
    color: ${darkMode ? grayLight : grayDark};
    cursor: default;
    max-height: ${maxHeight || 'none'};
    overflow-y: auto;
  `;
});
const Items = styled('div', getStyledOptions())(props => {
    const { grayDark, grayDarker, grayLight, white } = getTheme(props);
    const darkMode = isDarkMode(props);
    return css `
    background-color: ${darkMode ? grayDarker : white};
    color: ${darkMode ? grayLight : grayDark};
  `;
});
const Search = styled('div', getStyledOptions())(props => {
    const { darkColor, grayDarker, grayLight, grayMid, lightColor, spacing, typography, white } = getTheme(props);
    const darkMode = isDarkMode(props);
    return css `
    ${getSharedStyles(spacing)};
    background-color: ${darkMode ? grayDarker : white};
    padding: ${spacing.sm};
    position: sticky;
    top: 0;

    input {
      background-color: ${darkMode ? grayDarker : white};
      border: 1px solid ${darkMode ? grayMid : grayLight};
      color: ${darkMode ? lightColor : darkColor};
      font-size: ${typography.regular.fontSize};
      line-height: 1.6;
      padding: ${spacing.xxs} ${spacing.sm};
      width: 100%;
    }
  `;
});
function DropdownOptions({ methods, onCreate, onSearch, props, shade, state, variant, }) {
    const { addItem, getLabels, getStyles, removeItem, setSearch } = methods;
    const { autoFocus, create, options, searchable } = props;
    const { cursor, search, values } = state;
    const searchInput = useRef(null);
    let children;
    if (create) {
        children = (_jsx(Add, { methods: methods, onCreate: onCreate, props: props, shade: shade, state: state, variant: variant }));
    }
    const regexp = new RegExp(search.replace(/[$()*+.?[\\\]^{|}]/g, '\\$&'), 'i');
    useEffect(() => {
        const { current } = searchInput;
        if (current && autoFocus) {
            current.focus();
        }
    }, [autoFocus]);
    const handleSearch = (event) => {
        const { value } = event.target;
        setSearch(event);
        if (onSearch) {
            onSearch(value);
        }
    };
    const availableOptions = options
        .filter(item => regexp.test(`${item.label || item.value}`))
        .map((option, index) => {
        const { disabled, label, prefix, suffix, value } = option;
        const isSelected = values.includes(option);
        const isHovered = cursor === index;
        return (_jsxs(Item, { "data-component-name": "DropdownItem", disabled: disabled, hovered: isHovered, onClick: () => (isSelected ? removeItem(null, option, false) : addItem(option)), role: "listitem", selected: isSelected, shade: shade, variant: variant, children: [prefix && (_jsx(BoxInline, { "data-component-name": "DropdownOptionPrefix", mr: "xxs", children: prefix })), _jsx(BoxInline, { flex: "grow", children: label || value }), suffix && (_jsx(BoxInline, { "data-component-name": "DropdownOptionSuffix", ml: "xxs", children: suffix }))] }, option.value));
    });
    const output = {
        options: availableOptions,
    };
    if (children && !availableOptions.length) {
        output.create = _jsx(Centered, { withBorder: !!availableOptions.length, children: children });
    }
    if (!children && !availableOptions.length) {
        output.options = _jsx(Empty, { children: getLabels().noData });
    }
    return (_jsxs(List, { "data-component-name": "DropdownOptions", maxHeight: getStyles().menuMaxHeight, children: [searchable && (_jsx(Search, { "data-component-name": "DropdownOptionsSearch", children: _jsx(Input, { ref: searchInput, onChange: handleSearch, shade: shade, type: "text", value: search, variant: variant }) })), _jsx(Items, { "data-component-name": "DropdownOptionsList", children: output.options }), output.create] }));
}
export default DropdownOptions;
//# sourceMappingURL=Items.js.map