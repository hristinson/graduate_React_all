import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useMemo } from 'react';
import { useFormContext, useWatch } from 'react-hook-form';
import { useSetState, useUnmount } from 'react-use';
import FieldCheckbox from './Checkbox';
import FieldDebug from './Debug';
import FieldDropdown from './Dropdown';
import FieldInput from './Input';
import FieldRadio from './Radio';
import FieldSelect from './Select';
import FieldTextarea from './Textarea';
import FieldToggle from './Toggle';
import { getDefaultValue, getError, getRegisterOptions } from './utils';
import { FormGroup } from '../FormGroup';
export function Field(props) {
    const { assistiveText, hideAssistiveText, id, inline, label, name, required, skipValidation, style, type = 'text', validations, value, } = props;
    const [{ isActive, isDirty }, setStatus] = useSetState({
        isActive: false,
        isDirty: false,
    });
    const { formState: { dirtyFields, errors }, getValues, register, setValue, unregister, } = useFormContext();
    const registerOptions = useMemo(() => getRegisterOptions({ ...props, getValues }), [getValues, props]);
    const registration = register(name, registerOptions);
    const currentValue = useWatch({
        name,
        defaultValue: getDefaultValue(value || getValues()[name], type),
    });
    const [error, errorType = ''] = getError(name, errors);
    useUnmount(() => {
        unregister(name);
    });
    const showError = !!error && errorType !== 'revalidate' && (!isActive || isDirty);
    const isValid = !!currentValue && !error && (required || validations?.length);
    const groupProps = {
        assistiveText,
        hideAssistiveText,
        inline,
        label,
        labelId: id || name,
        required,
        style,
    };
    const output = { error };
    /* istanbul ignore else */
    if (!skipValidation) {
        groupProps.skipIcon = ['checkbox', 'dropdown', 'radio', 'select', 'toggle'].includes(type);
        if (showError) {
            groupProps.error = error;
            groupProps.valid = false;
        }
        else if (isValid) {
            groupProps.valid = true;
        }
    }
    switch (type) {
        case 'checkbox': {
            output.content = (_jsx(FieldCheckbox, { currentValue: currentValue, setValue: setValue, ...props }));
            break;
        }
        case 'dropdown': {
            output.content = (_jsx(FieldDropdown, { currentValue: currentValue, registration: registration, setValue: setValue, ...props }));
            break;
        }
        case 'radio': {
            output.content = _jsx(FieldRadio, { registration: registration, ...props });
            break;
        }
        case 'select': {
            output.content = (_jsx(FieldSelect, { isDirty: !!dirtyFields[name], registration: registration, setStatus: setStatus, ...props }));
            break;
        }
        case 'textarea': {
            output.content = (_jsx(FieldTextarea, { isDirty: !!dirtyFields[name], registration: registration, setStatus: setStatus, ...props }));
            break;
        }
        case 'toggle': {
            output.content = _jsx(FieldToggle, { ...props, setValue: setValue });
            break;
        }
        default: {
            output.content = (_jsx(FieldInput, { currentValue: currentValue, isDirty: !!dirtyFields[name], registration: registration, setStatus: setStatus, ...props }));
        }
    }
    if (type === 'hidden') {
        return output.content;
    }
    return (_jsxs(FormGroup, { "data-component-name": "Field", ...groupProps, children: [output.content, _jsx(FieldDebug, { ...props })] }));
}
Field.defaultProps = {
    debug: false,
    disabled: false,
    hideAssistiveText: false,
    inline: false,
    label: '',
    readOnly: false,
    required: false,
    skipValidation: false,
    type: 'text',
};
//# sourceMappingURL=index.js.map