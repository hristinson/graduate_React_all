"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.textStyles = exports.textColorStyles = exports.shadowStyles = exports.radiusStyles = exports.positioningStyles = exports.paddingStyles = exports.outlineStyles = exports.marginStyles = exports.layoutStyles = exports.inputStyles = exports.flexItemStyles = exports.flexBoxStyles = exports.displayStyles = exports.colorStyles = exports.buttonStyles = exports.borderStyles = exports.baseStyles = exports.backgroundStyles = exports.appearanceStyles = exports.alignStyles = exports.isDarkMode = exports.getStyledOptions = void 0;
const is_prop_valid_1 = require("@emotion/is-prop-valid");
const react_1 = require("@emotion/react");
const helpers_1 = require("@gilbarbara/helpers");
const is_lite_1 = require("is-lite");
const polished_1 = require("polished");
const helpers_2 = require("./helpers");
function getStyledOptions(...exclude) {
    return {
        shouldForwardProp: (prop) => (0, is_prop_valid_1.default)(prop) &&
            ![
                'color',
                'direction',
                'display',
                'height',
                'loading',
                'margin',
                'opacity',
                'overflow',
                'padding',
                'pointerEvents',
                'radius',
                'shadow',
                'size',
                'transform',
                'width',
                'wrap',
                ...exclude,
            ].includes(prop) &&
            !['onClear', 'onCreate', 'onDropdown', 'onOpen', 'onSelect'].some(d => prop.startsWith(d)),
    };
}
exports.getStyledOptions = getStyledOptions;
function isDarkMode(props) {
    return !!props?.theme?.darkMode;
}
exports.isDarkMode = isDarkMode;
function alignStyles(props) {
    const { align } = props;
    if (align) {
        return {
            textAlign: align,
        };
    }
    return {};
}
exports.alignStyles = alignStyles;
exports.appearanceStyles = {
    appearance: 'none',
};
function backgroundStyles(props, withBorder = true) {
    const { variants } = (0, helpers_2.getTheme)(props);
    const { invert, shade = 'mid', transparent, variant } = props;
    if (variant) {
        const { bg, color } = (0, helpers_2.getColorVariant)(variant, shade, variants);
        const styles = {
            backgroundColor: invert || transparent ? 'transparent' : bg,
            color: invert || transparent ? bg : color,
        };
        if (withBorder) {
            styles.border = transparent ? 0 : `1px solid ${bg}`;
        }
        return styles;
    }
    return {};
}
exports.backgroundStyles = backgroundStyles;
function baseStyles(props) {
    const { fontFamily } = (0, helpers_2.getTheme)(props);
    return {
        boxSizing: 'border-box',
        fontFamily,
    };
}
exports.baseStyles = baseStyles;
function borderStyles(props) {
    const { border } = props;
    const { variants } = (0, helpers_2.getTheme)(props);
    let { bg: borderColor } = (0, helpers_2.getColorVariant)('gray', 'lighter', variants);
    const defaultBorder = `1px solid ${borderColor}`;
    let output = {};
    const getBorderValue = (side, value = defaultBorder) => {
        const item = {};
        if (['bottom', 'left', 'right', 'top'].includes(side)) {
            item[`border${(0, helpers_1.capitalize)(side)}`] = value;
        }
        else if (['start', 'end'].includes(side)) {
            item[`borderInline${(0, helpers_1.capitalize)(side)}`] = value;
        }
        else if (side === 'horizontal') {
            item.borderBottom = value;
            item.borderTop = value;
        }
        else if (side === 'vertical') {
            item.borderLeft = value;
            item.borderRight = value;
        }
        else {
            item.border = value;
        }
        return item;
    };
    if (is_lite_1.default.nullOrUndefined(border)) {
        return output;
    }
    if (is_lite_1.default.boolean(border)) {
        output.border = border ? defaultBorder : undefined;
    }
    else if (is_lite_1.default.string(border)) {
        output = getBorderValue(border);
    }
    else if (is_lite_1.default.array(border)) {
        const items = [];
        border.forEach(item => {
            const { color, shade = 'lighter', side, size = '1px', style = 'solid', variant = 'gray', } = item;
            ({ bg: borderColor } = (0, helpers_2.getColorVariant)(variant, shade, variants));
            const value = `${(0, helpers_2.px)(size)} ${style} ${color || borderColor}`;
            items.push(getBorderValue(side, value));
        });
        output = items.reduce((acc, item) => {
            Object.entries(item).forEach(([key, value]) => {
                acc[key] = value;
            });
            return acc;
        }, {});
    }
    return output;
}
exports.borderStyles = borderStyles;
exports.buttonStyles = {
    ...exports.appearanceStyles,
    backgroundColor: 'transparent',
    border: 0,
};
function colorStyles(props) {
    const { shade = 'mid', variant } = props;
    const { variants } = (0, helpers_2.getTheme)(props);
    if (variant) {
        const { bg } = (0, helpers_2.getColorVariant)(variant, shade, variants);
        return {
            color: bg,
        };
    }
    return {};
}
exports.colorStyles = colorStyles;
function displayStyles(props) {
    const { display } = props;
    if (display) {
        return { display };
    }
    return {};
}
exports.displayStyles = displayStyles;
function flexBoxStyles(props) {
    const { align, alignContent, direction, justify, wrap } = props;
    return {
        alignContent,
        alignItems: align,
        flexDirection: direction,
        flexWrap: wrap,
        justifyContent: justify,
    };
}
exports.flexBoxStyles = flexBoxStyles;
function flexItemStyles(props) {
    const { alignSelf, basis, fill, flex, justifySelf, order } = props;
    const output = {};
    if (!is_lite_1.default.nullOrUndefined(fill)) {
        output.height = fill === true || fill === 'vertical' ? '100%' : undefined;
        output.width = fill === true || fill === 'horizontal' ? '100%' : undefined;
    }
    if (!is_lite_1.default.nullOrUndefined(flex)) {
        if (is_lite_1.default.boolean(flex)) {
            output.flex = flex ? '1 1' : '0 0';
        }
        if (is_lite_1.default.string(flex)) {
            output.flex = flex === 'grow' ? '1 0' : '0 1';
        }
        if (is_lite_1.default.plainObject(flex)) {
            output.flex = `${flex.grow ? flex.grow : 0} ${flex.shrink ? flex.shrink : 0}`;
        }
    }
    return {
        ...output,
        alignSelf,
        flexBasis: basis,
        justifySelf,
        order,
    };
}
exports.flexItemStyles = flexItemStyles;
function inputStyles(props, type) {
    const { borderless, large, multiple, prefixSpacing, suffixSpacing, width } = props;
    const darkMode = isDarkMode(props);
    const { colors, darkColor, fontFamily, grayDark, grayDarker, grayLighter, grayLightest, grayMid, inputHeight, lightColor, radius, spacing, typography, white, } = (0, helpers_2.getTheme)(props);
    const isSelect = is_lite_1.default.boolean(multiple);
    const placeholderColor = grayMid;
    let height;
    let paddingY = large ? spacing.md : spacing.sm;
    let paddingLeft = borderless ? 0 : spacing.md;
    let paddingRight = borderless ? 0 : spacing.md;
    if (type === 'textarea') {
        paddingY = spacing.xs;
    }
    if (type !== 'textarea' && !multiple) {
        height = large ? inputHeight.large : inputHeight.normal;
    }
    if (isSelect) {
        paddingY = large ? spacing.sm : spacing.xs;
        paddingRight = spacing.lg;
    }
    if (prefixSpacing) {
        paddingLeft = is_lite_1.default.boolean(prefixSpacing) ? '40px' : (0, helpers_2.px)(prefixSpacing);
    }
    if (suffixSpacing) {
        paddingRight = is_lite_1.default.boolean(suffixSpacing) ? '40px' : (0, helpers_2.px)(suffixSpacing);
    }
    const disabled = (0, react_1.css) `
    ${!borderless && `background-color: ${darkMode ? grayDark : grayLightest}`};
    border-color: ${darkMode ? grayDark : grayLighter};
    color: ${darkMode ? grayLighter : grayDark};
    cursor: not-allowed;
  `;
    const styles = borderless
        ? (0, react_1.css) `
        background-color: transparent;
        border: 0;
        border-bottom: 1px solid ${darkMode ? grayDark : grayMid};
      `
        : (0, react_1.css) `
        background-color: ${darkMode ? grayDarker : white};
        border: 1px solid ${darkMode ? grayDark : grayMid};
        border-radius: ${radius.xs};
      `;
    return (0, react_1.css) `
    color: ${darkMode ? lightColor : darkColor};
    display: block;
    font-family: ${fontFamily};
    font-size: ${typography.regular.fontSize};
    height: ${height};
    line-height: 1.4;
    padding: ${paddingY} ${paddingRight} ${paddingY} ${paddingLeft};
    width: ${width ? (0, helpers_2.px)(width) : '100%'};
    ${styles};

    &:focus {
      ${!!borderless && `border-color: ${colors.primary}`};
      box-shadow: ${borderless ? '' : `0 0 8px 1px ${(0, polished_1.rgba)(colors.primary, 1)}`};
      outline: none;
    }

    &:disabled {
      ${disabled};
    }

    ${!isSelect &&
        (0, react_1.css) `
      &::placeholder {
        color: ${placeholderColor};
      }

      &:not(:placeholder-shown) {
        border-color: ${colors.primary};
      }

      &:read-only {
        ${disabled};
      }
    `};
  `;
}
exports.inputStyles = inputStyles;
function layoutStyles(props) {
    const { display, height, maxHeight, maxWidth, minHeight, minWidth, opacity, overflow, pointerEvents, textAlign, transform, transformOrigin, transition, width, } = props;
    const output = {
        opacity,
        overflow,
        pointerEvents,
        textAlign,
        transition,
        transform,
        transformOrigin,
    };
    if (!is_lite_1.default.nullOrUndefined(display)) {
        output.display = display;
    }
    if (!is_lite_1.default.nullOrUndefined(height)) {
        output.height = (0, helpers_2.px)(height);
    }
    if (!is_lite_1.default.nullOrUndefined(maxHeight)) {
        output.maxHeight = (0, helpers_2.px)(maxHeight);
    }
    if (!is_lite_1.default.nullOrUndefined(maxWidth)) {
        output.maxWidth = (0, helpers_2.px)(maxWidth);
    }
    if (!is_lite_1.default.nullOrUndefined(minHeight)) {
        output.minHeight = (0, helpers_2.px)(minHeight);
    }
    if (!is_lite_1.default.nullOrUndefined(minWidth)) {
        output.minWidth = (0, helpers_2.px)(minWidth);
    }
    if (!is_lite_1.default.nullOrUndefined(width)) {
        output.width = (0, helpers_2.px)(width);
    }
    return output;
}
exports.layoutStyles = layoutStyles;
function marginStyles(props) {
    const { margin, mb, ml, mr, mt, mx, my } = props;
    const { spacing } = (0, helpers_2.getTheme)(props);
    const output = {};
    if (!is_lite_1.default.undefined(margin)) {
        output.margin = margin ? spacing[margin] : margin;
    }
    if (!is_lite_1.default.undefined(my)) {
        output.marginBottom = my ? spacing[my] : my;
        output.marginTop = my ? spacing[my] : my;
    }
    else {
        if (!is_lite_1.default.undefined(mb)) {
            output.marginBottom = mb === 'auto' || mb === 0 ? mb : spacing[mb];
        }
        if (!is_lite_1.default.undefined(mt)) {
            output.marginTop = mt === 'auto' || mt === 0 ? mt : spacing[mt];
        }
    }
    if (!is_lite_1.default.undefined(mx)) {
        output.marginLeft = mx === 'auto' || mx === 0 ? mx : spacing[mx];
        output.marginRight = mx === 'auto' || mx === 0 ? mx : spacing[mx];
    }
    else {
        if (!is_lite_1.default.undefined(ml)) {
            output.marginLeft = ml === 'auto' || ml === 0 ? ml : spacing[ml];
        }
        if (!is_lite_1.default.undefined(mr)) {
            output.marginRight = mr === 'auto' || mr === 0 ? mr : spacing[mr];
        }
    }
    return output;
}
exports.marginStyles = marginStyles;
function outlineStyles(props) {
    const { colors } = (0, helpers_2.getTheme)(props);
    return {
        boxShadow: `0 0 6px 0 ${(0, polished_1.rgba)(colors.primary, 0.6)}`,
    };
}
exports.outlineStyles = outlineStyles;
function paddingStyles(props, force = false) {
    const { padding, pb, pl, pr, pt, px: paddingX, py } = props;
    const { spacing } = (0, helpers_2.getTheme)(props);
    const output = {};
    if (padding) {
        output.padding = spacing[padding];
    }
    if (py) {
        output.paddingBottom = spacing[py];
        output.paddingTop = spacing[py];
    }
    else {
        if (pb) {
            output.paddingBottom = spacing[pb];
        }
        if (pt) {
            output.paddingTop = spacing[pt];
        }
    }
    if (paddingX) {
        output.paddingLeft = spacing[paddingX];
        output.paddingRight = spacing[paddingX];
    }
    else {
        if (pl) {
            output.paddingLeft = spacing[pl];
        }
        if (pr) {
            output.paddingRight = spacing[pr];
        }
    }
    if (force) {
        return Object.entries(output).reduce((acc, [key, value]) => {
            acc[key] = `${value} !important`;
            return acc;
        }, {});
    }
    return output;
}
exports.paddingStyles = paddingStyles;
function positioningStyles(props) {
    const { bottom, left, position, right, top, zIndex } = props;
    const output = {
        position,
        zIndex,
    };
    if (!is_lite_1.default.nullOrUndefined(bottom)) {
        output.bottom = (0, helpers_2.px)(bottom);
    }
    if (!is_lite_1.default.nullOrUndefined(left)) {
        output.left = (0, helpers_2.px)(left);
    }
    if (!is_lite_1.default.nullOrUndefined(right)) {
        output.right = (0, helpers_2.px)(right);
    }
    if (!is_lite_1.default.nullOrUndefined(top)) {
        output.top = (0, helpers_2.px)(top);
    }
    return output;
}
exports.positioningStyles = positioningStyles;
function radiusStyles(props) {
    const { radius } = (0, helpers_2.getTheme)(props);
    if (props.radius) {
        return {
            borderRadius: radius[props.radius],
        };
    }
    return {};
}
exports.radiusStyles = radiusStyles;
function shadowStyles(props) {
    const { shadow } = (0, helpers_2.getTheme)(props);
    if (props.shadow) {
        return {
            boxShadow: isDarkMode(props)
                ? shadow[props.shadow].replace(/148/g, '222')
                : shadow[props.shadow],
        };
    }
    return {};
}
exports.shadowStyles = shadowStyles;
function textColorStyles(props) {
    const { color, colorShade = 'mid', colorVariant } = props;
    const { variants } = (0, helpers_2.getTheme)(props);
    if (color) {
        return {
            color,
        };
    }
    if (colorVariant) {
        const { bg } = (0, helpers_2.getColorVariant)(colorVariant, colorShade, variants);
        return {
            color: bg,
        };
    }
    return {};
}
exports.textColorStyles = textColorStyles;
function textStyles(props, lineHeightCustom) {
    const { bold = false, size } = props;
    const { typography } = (0, helpers_2.getTheme)(props);
    if (size) {
        const { fontSize, lineHeight, weight } = typography[size];
        const fontWeight = bold ? weight[1] : weight[0];
        return {
            fontSize,
            fontWeight,
            lineHeight: lineHeightCustom || lineHeight,
        };
    }
    return {};
}
exports.textStyles = textStyles;
//# sourceMappingURL=system.js.map