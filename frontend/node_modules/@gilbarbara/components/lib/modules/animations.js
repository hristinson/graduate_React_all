"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.scrollTo = exports.scrollDocument = exports.rotate = exports.fadeInOut = exports.fadeOut = exports.fadeIn = exports.animateIcon = void 0;
const react_1 = require("@emotion/react");
const scroll = require("scroll");
const baseTheme = require("./theme");
function animateIcon(target, color = 'primary', theme = baseTheme) {
    const { black, colors, gray, white } = theme;
    /* istanbul ignore else */
    if (target) {
        const icon = target.querySelector('[data-component-name="Icon"]');
        if (!icon) {
            return;
        }
        const getColor = (variant) => {
            switch (variant) {
                case 'black': {
                    return black;
                }
                case 'white': {
                    return white;
                }
                case 'gray': {
                    return gray;
                }
                // No default
            }
            return colors[variant];
        };
        const iconClone = document.createElement('span');
        iconClone.innerHTML = icon.innerHTML;
        iconClone.classList.add(icon.className, 'will-animate');
        iconClone.setAttribute('style', `color: ${getColor(color)}; position: absolute; top: ${icon.offsetTop}px; left: ${icon.offsetLeft}px`);
        target.appendChild(iconClone);
        setTimeout(() => {
            iconClone.classList.add('is-animating');
        }, 100);
        target.addEventListener('transitionend', () => {
            /* istanbul ignore else */
            if (iconClone.parentNode !== null && iconClone.classList.contains('is-animating')) {
                iconClone.parentNode.removeChild(iconClone);
            }
        });
    }
}
exports.animateIcon = animateIcon;
exports.fadeIn = (0, react_1.keyframes) `
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
`;
exports.fadeOut = (0, react_1.keyframes) `
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
exports.fadeInOut = (0, react_1.keyframes) `
  0% {
    opacity: 0;
  }

  50% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
exports.rotate = (0, react_1.keyframes) `
  100% {
    transform: rotate(360deg);
  }
`;
function scrollDocument() {
    return document.scrollingElement || document.createElement('body');
}
exports.scrollDocument = scrollDocument;
function scrollTo(value, options = {}) {
    const { element = scrollDocument(), scrollDuration = 400 } = options;
    return new Promise((resolve, reject) => {
        const { scrollTop } = element;
        const nextValue = scrollDocument().scrollTop + value;
        const limit = nextValue > scrollTop ? nextValue - scrollTop : scrollTop - nextValue;
        scroll.top(element, nextValue, { duration: limit < 100 ? 50 : scrollDuration }, (error) => {
            if (error && error.message !== 'Element already at target scroll position') {
                return reject(error);
            }
            return resolve();
        });
    });
}
exports.scrollTo = scrollTo;
//# sourceMappingURL=animations.js.map