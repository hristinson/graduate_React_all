"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tooltip = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_innertext_1 = require("react-innertext");
const react_2 = require("@emotion/react");
const styled_1 = require("@emotion/styled");
const is_lite_1 = require("is-lite");
const animations_1 = require("./modules/animations");
const helpers_1 = require("./modules/helpers");
const system_1 = require("./modules/system");
const Text_1 = require("./Text");
const arrowDistance = -3;
const arrowSize = 10;
const arrowSpacing = arrowSize + 2;
const StyledTooltip = (0, styled_1.default)('span', (0, system_1.getStyledOptions)()) `
  ${system_1.baseStyles};
  display: inline-flex;
  line-height: 1;
  position: relative;
`;
const StyledArrow = styled_1.default.span(props => {
    const { align, bg, position } = props;
    const styles = {};
    const distance = '10px';
    const offset = '-7px';
    let arrowTranslate = '';
    switch (position) {
        case 'bottom': {
            styles.top = offset;
            arrowTranslate = 'translate(-2px, 2px)';
            break;
        }
        case 'left': {
            styles.right = offset;
            arrowTranslate = 'translate(-2px, -2px)';
            break;
        }
        case 'right': {
            styles.left = offset;
            arrowTranslate = 'translate(2px, 2px)';
            break;
        }
        case 'top': {
            styles.bottom = offset;
            arrowTranslate = 'translate(2px, -2px)';
            break;
        }
        // No default
    }
    if (['bottom', 'top'].includes(position)) {
        if (align === 'start') {
            styles.left = distance;
        }
        else if (align === 'middle') {
            styles.left = '50%';
            styles.transform = 'translateX(-50%)';
        }
        else {
            styles.right = distance;
        }
    }
    else if (['left', 'right'].includes(position)) {
        if (align === 'start') {
            styles.top = distance;
        }
        else if (align === 'middle') {
            styles.top = '50%';
            styles.transform = 'translateY(-50%)';
        }
        else {
            styles.bottom = distance;
        }
    }
    return (0, react_2.css) `
    display: block;
    height: ${(0, helpers_1.px)(arrowSize)};
    position: absolute;
    width: ${(0, helpers_1.px)(arrowSize)};
    z-index: 5;
    ${styles};

    &:before {
      background-color: ${bg};
      border-radius: 1px;
      content: '';
      display: block;
      height: ${(0, helpers_1.px)(arrowSize)};
      position: absolute;
      transform: rotate(-45deg) ${arrowTranslate};
      width: ${(0, helpers_1.px)(arrowSize)};
    }
  `;
});
const StyledBody = (0, styled_1.default)('span', (0, system_1.getStyledOptions)())(props => {
    const { align, bg, color, position, size, wrap } = props;
    const { radius, spacing } = (0, helpers_1.getTheme)(props);
    const styles = {};
    if (align === 'start') {
        if (['left', 'right'].includes(position)) {
            styles.top = (0, helpers_1.px)(arrowDistance);
        }
        else {
            styles.left = (0, helpers_1.px)(arrowDistance);
        }
    }
    else if (align === 'middle') {
        if (['left', 'right'].includes(position)) {
            styles.top = '50%';
            styles.transform = 'translateY(-50%)';
        }
        else {
            styles.left = '50%';
            styles.transform = 'translateX(-50%)';
        }
    }
    else if (['left', 'right'].includes(position)) {
        styles.bottom = (0, helpers_1.px)(arrowDistance);
    }
    else {
        styles.right = (0, helpers_1.px)(arrowDistance);
    }
    switch (position) {
        case 'bottom': {
            styles.marginTop = arrowSpacing;
            styles.top = '100%';
            break;
        }
        case 'left': {
            styles.right = '100%';
            styles.marginRight = arrowSpacing;
            break;
        }
        case 'right': {
            styles.left = '100%';
            styles.marginLeft = arrowSpacing;
            break;
        }
        case 'top': {
            styles.bottom = '100%';
            styles.marginBottom = arrowSpacing;
            break;
        }
    }
    switch (size) {
        case 'small':
        case 'mid': {
            styles.padding = `${spacing.xxs} ${spacing.xs}`;
            break;
        }
        default: {
            styles.padding = `${spacing.xs} ${spacing.sm}`;
            break;
        }
    }
    let width;
    switch (wrap) {
        case 'sm': {
            width = '100px';
            break;
        }
        case 'md': {
            width = '200px';
            break;
        }
        case 'lg': {
            width = '320px';
            break;
        }
    }
    return (0, react_2.css) `
    animation: ${animations_1.fadeIn} 0.2s forwards;
    background-color: ${bg};
    border-radius: ${radius.xxs};
    color: ${color};
    position: absolute;
    text-align: center;
    white-space: ${wrap ? 'initial' : 'nowrap'};
    width: ${width};
    ${styles};
  `;
});
const StyledContent = (0, styled_1.default)(Text_1.Text) `
  position: relative;
  z-index: 10;
`;
function TooltipBody(props) {
    const { align = 'middle', bg, bold, color, content, position = 'right', size = 'mid', style, wrap, } = props;
    return ((0, jsx_runtime_1.jsxs)(StyledBody, { align: align, bg: bg, color: color, "data-component-name": "TooltipBody", position: position, size: size, style: style, wrap: wrap, children: [(0, react_1.isValidElement)(content) ? (content) : ((0, jsx_runtime_1.jsx)(StyledContent, { bold: bold, "data-component-name": "TooltipContent", size: size, children: content })), (0, jsx_runtime_1.jsx)(StyledArrow, { align: align, bg: bg, color: color, "data-component-name": "TooltipArrow", position: position })] }));
}
function Tooltip(props) {
    const { children, content, open, shade, variant = 'gray' } = props;
    const isActive = (0, react_1.useRef)(false);
    const [isOpen, setOpen] = (0, react_1.useState)(open || false);
    const { variants } = (0, helpers_1.getTheme)({ theme: (0, react_2.useTheme)() });
    const text = (0, react_innertext_1.default)(content);
    const { bg, color } = (0, helpers_1.getColorVariant)(variant, shade, variants);
    (0, react_1.useEffect)(() => {
        isActive.current = true;
        return () => {
            isActive.current = false;
        };
    }, []);
    const handleMouseEnter = () => {
        if (!is_lite_1.default.boolean(open)) {
            setOpen(true);
        }
    };
    const handleMouseLeave = () => {
        if (!is_lite_1.default.boolean(open)) {
            setOpen(false);
        }
    };
    return ((0, jsx_runtime_1.jsxs)(StyledTooltip, { "aria-label": text, "data-component-name": "Tooltip", onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, role: "tooltip", children: [children, isOpen && (0, jsx_runtime_1.jsx)(TooltipBody, { ...props, bg: bg, color: color })] }));
}
exports.Tooltip = Tooltip;
Tooltip.defaultProps = {
    align: 'middle',
    bold: false,
    position: 'bottom',
    shade: 'dark',
    size: 'mid',
    variant: 'gray',
};
//# sourceMappingURL=Tooltip.js.map