"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = exports.StyledSearch = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_use_1 = require("react-use");
const react_2 = require("@emotion/react");
const styled_1 = require("@emotion/styled");
const Items_1 = require("./Items");
const Box_1 = require("../Box");
const ClickOutside_1 = require("../ClickOutside");
const ComponentWrapper_1 = require("../ComponentWrapper");
const Icon_1 = require("../Icon");
const Input_1 = require("../Input");
const helpers_1 = require("../modules/helpers");
const system_1 = require("../modules/system");
exports.StyledSearch = (0, styled_1.default)(Box_1.Box, (0, system_1.getStyledOptions)())(props => {
    const { width } = props;
    return (0, react_2.css) `
    position: relative;
    width: ${width ? (0, helpers_1.px)(width) : '100%'};
    ${(0, system_1.marginStyles)(props)};
  `;
});
function Search(props) {
    const { borderless, debounce, height = 230, hideIcon, icon = 'search', items, loading, onFocus, onSearch, onSelect, onType, placeholder, showListOnFocus, ...rest } = props;
    const optionsRef = (0, react_1.useRef)(null);
    const isActive = (0, react_1.useRef)(false);
    const [{ active, currentItems, cursor, focus, typing, value }, setState] = (0, react_use_1.useSetState)({
        active: false,
        currentItems: items,
        cursor: -1,
        focus: false,
        typing: false,
        value: '',
    });
    const timeout = (0, react_1.useRef)(0);
    const { colors } = (0, helpers_1.getTheme)({ theme: (0, react_2.useTheme)() });
    (0, react_1.useEffect)(() => {
        isActive.current = true;
        return () => {
            isActive.current = false;
        };
    }, []);
    const updateState = (state) => {
        if (isActive.current) {
            setState(state);
        }
    };
    const close = () => {
        updateState({ active: false });
    };
    const handleBlur = () => {
        updateState({ cursor: -1, focus: false });
    };
    const handleChange = (event) => {
        const inputValue = event.target.value;
        if (onType) {
            onType(inputValue);
        }
        const nextState = { active: !!inputValue, value: inputValue };
        if (debounce) {
            updateState({ ...nextState, typing: true });
            clearTimeout(timeout.current);
            timeout.current = window.setTimeout(() => {
                updateState({
                    typing: false,
                    currentItems: items.filter(d => d.value.toLowerCase().includes(inputValue.toLowerCase())),
                });
                if (onSearch) {
                    onSearch(inputValue);
                }
                timeout.current = 0;
            }, debounce);
        }
        else {
            updateState({
                ...nextState,
                currentItems: items.filter(d => d.value.toLowerCase().includes(inputValue.toLowerCase())),
            });
            if (onSearch) {
                onSearch(inputValue);
            }
        }
    };
    const handleFocus = (event) => {
        const inputValue = event.target.value;
        updateState({ active: showListOnFocus && !!currentItems.length, focus: true });
        if (onFocus) {
            onFocus(inputValue);
        }
    };
    const handleKeyDown = (event) => {
        const { code, shiftKey } = event;
        const optionElement = optionsRef.current;
        if (!active || !optionElement) {
            return;
        }
        let nextCursor = cursor;
        if (((code === 'Tab' && !shiftKey) || code === 'ArrowDown') &&
            cursor < currentItems.length - 1) {
            nextCursor++;
            event.preventDefault();
        }
        else if (((code === 'Tab' && shiftKey) || code === 'ArrowUp') && cursor > 0) {
            nextCursor--;
            event.preventDefault();
        }
        else if (code === 'Enter') {
            const { dataset } = optionElement.children[cursor];
            updateState({ active: false, value: '' });
            onSelect(dataset.value || '');
        }
        updateState({ cursor: nextCursor });
        if (optionElement.children[nextCursor]) {
            optionElement.children[nextCursor].scrollIntoView({ block: 'end' });
        }
    };
    const handleSelect = (event) => {
        const { dataset } = event.currentTarget;
        updateState({ active: false, value: '' });
        onSelect(dataset.value || '');
    };
    let prefixSpacing = borderless ? 32 : true;
    if (hideIcon) {
        prefixSpacing = false;
    }
    return ((0, jsx_runtime_1.jsx)(exports.StyledSearch, { "data-component-name": "Search", ...rest, children: (0, jsx_runtime_1.jsxs)(ClickOutside_1.ClickOutside, { active: active, onClick: close, children: [(0, jsx_runtime_1.jsx)(ComponentWrapper_1.ComponentWrapper, { prefix: hideIcon ? undefined : ((0, jsx_runtime_1.jsx)(Icon_1.Icon, { color: focus || value ? colors.primary : undefined, name: icon, size: 24 })), size: borderless ? [24, 40] : 40, suffix: typing || loading ? (0, jsx_runtime_1.jsx)(Icon_1.Icon, { name: "spinner", spin: true }) : undefined, children: (0, jsx_runtime_1.jsx)(Input_1.Input, { autoComplete: "off", borderless: borderless, name: "search", onBlur: handleBlur, onChange: handleChange, onFocus: handleFocus, onKeyDown: handleKeyDown, placeholder: placeholder, prefixSpacing: prefixSpacing, value: value }) }), (0, jsx_runtime_1.jsx)(Items_1.default, { ref: optionsRef, active: active, cursor: cursor, height: height, items: currentItems, onSelect: handleSelect, ...rest })] }) }));
}
exports.Search = Search;
Search.defaultProps = {
    borderless: false,
    debounce: 0,
    height: 230,
    hideIcon: false,
    icon: 'search',
    loading: false,
    noResultsLabel: 'Nothing found',
    placeholder: 'Search for...',
    showListOnFocus: true,
};
//# sourceMappingURL=index.js.map