"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const react_2 = require("@emotion/react");
const styled_1 = require("@emotion/styled");
const Add_1 = require("./Add");
const Box_1 = require("../Box");
const helpers_1 = require("../modules/helpers");
const system_1 = require("../modules/system");
const getSharedStyles = (spacing) => (0, react_2.css) `
  align-items: center;
  display: flex;
  padding: ${spacing.xs} ${spacing.sm};
  width: 100%;
`;
const Centered = (0, styled_1.default)('div', (0, system_1.getStyledOptions)())(props => {
    const { withBorder } = props;
    const { grayLight, spacing } = (0, helpers_1.getTheme)(props);
    return (0, react_2.css) `
    ${getSharedStyles(spacing)};
    border-top: ${withBorder ? `1px solid ${grayLight}` : 0};
    justify-content: center;
    padding: 0;
  `;
});
const Empty = (0, styled_1.default)('div', (0, system_1.getStyledOptions)())(props => {
    const { spacing } = (0, helpers_1.getTheme)(props);
    return (0, react_2.css) `
    ${getSharedStyles(spacing)};
    justify-content: center;
  `;
});
const Input = (0, styled_1.default)('input', (0, system_1.getStyledOptions)())(props => {
    const { shade, variant = 'primary' } = props;
    const { radius, variants } = (0, helpers_1.getTheme)(props);
    const { bg } = (0, helpers_1.getColorVariant)(variant, shade, variants);
    return (0, react_2.css) `
    border-radius: ${radius.xs};

    :focus {
      filter: drop-shadow(0 0 2px ${bg});
      outline: none;
    }
  `;
});
const Item = (0, styled_1.default)('div', (0, system_1.getStyledOptions)())(props => {
    const { disabled, hovered, selected, shade, variant = 'primary' } = props;
    const { darkMode, grayDark, grayDarker, grayLight, grayLighter, grayLightest, grayMid, spacing, variants, white, } = (0, helpers_1.getTheme)(props);
    const { bg, color } = (0, helpers_1.getColorVariant)(variant, shade, variants);
    const { bg: bgHoverLight, color: colorHoverLight } = (0, helpers_1.getColorVariant)(variant, 'lightest', variants);
    const { bg: bgHoverDark, color: colorHoverDark } = (0, helpers_1.getColorVariant)(variant, 'darker', variants);
    let itemBgColor = darkMode ? grayDarker : white;
    let itemColor = darkMode ? grayLighter : grayDarker;
    const bgHover = darkMode ? bgHoverDark : bgHoverLight;
    const colorHover = darkMode ? colorHoverDark : colorHoverLight;
    if (disabled) {
        itemBgColor = darkMode ? grayDark : grayLightest;
        itemColor = darkMode ? grayLight : grayMid;
    }
    return (0, react_2.css) `
    ${getSharedStyles(spacing)};
    background-color: ${itemBgColor};
    color: ${itemColor};
    cursor: pointer;
    pointer-events: ${disabled ? 'none' : undefined};
    ${selected &&
        (0, react_2.css) `
      background-color: ${bg};
      color: ${color};
    `};
    ${hovered &&
        !disabled &&
        (0, react_2.css) `
      background-color: ${bgHover};
      color: ${colorHover};
    `};

    &:hover {
      background-color: ${bgHover};
      color: ${colorHover};
    }
  `;
});
const List = (0, styled_1.default)('div', (0, system_1.getStyledOptions)())(props => {
    const { maxHeight } = props;
    const { grayDark, grayDarker, grayLight, white } = (0, helpers_1.getTheme)(props);
    const darkMode = (0, system_1.isDarkMode)(props);
    return (0, react_2.css) `
    background-color: ${darkMode ? grayDarker : white};
    color: ${darkMode ? grayLight : grayDark};
    cursor: default;
    max-height: ${maxHeight || 'none'};
    overflow-y: auto;
  `;
});
const Items = (0, styled_1.default)('div', (0, system_1.getStyledOptions)())(props => {
    const { grayDark, grayDarker, grayLight, white } = (0, helpers_1.getTheme)(props);
    const darkMode = (0, system_1.isDarkMode)(props);
    return (0, react_2.css) `
    background-color: ${darkMode ? grayDarker : white};
    color: ${darkMode ? grayLight : grayDark};
  `;
});
const Search = (0, styled_1.default)('div', (0, system_1.getStyledOptions)())(props => {
    const { darkColor, grayDarker, grayLight, grayMid, lightColor, spacing, typography, white } = (0, helpers_1.getTheme)(props);
    const darkMode = (0, system_1.isDarkMode)(props);
    return (0, react_2.css) `
    ${getSharedStyles(spacing)};
    background-color: ${darkMode ? grayDarker : white};
    padding: ${spacing.sm};
    position: sticky;
    top: 0;

    input {
      background-color: ${darkMode ? grayDarker : white};
      border: 1px solid ${darkMode ? grayMid : grayLight};
      color: ${darkMode ? lightColor : darkColor};
      font-size: ${typography.regular.fontSize};
      line-height: 1.6;
      padding: ${spacing.xxs} ${spacing.sm};
      width: 100%;
    }
  `;
});
function DropdownOptions({ methods, onCreate, onSearch, props, shade, state, variant, }) {
    const { addItem, getLabels, getStyles, removeItem, setSearch } = methods;
    const { autoFocus, create, options, searchable } = props;
    const { cursor, search, values } = state;
    const searchInput = (0, react_1.useRef)(null);
    let children;
    if (create) {
        children = ((0, jsx_runtime_1.jsx)(Add_1.default, { methods: methods, onCreate: onCreate, props: props, shade: shade, state: state, variant: variant }));
    }
    const regexp = new RegExp(search.replace(/[$()*+.?[\\\]^{|}]/g, '\\$&'), 'i');
    (0, react_1.useEffect)(() => {
        const { current } = searchInput;
        if (current && autoFocus) {
            current.focus();
        }
    }, [autoFocus]);
    const handleSearch = (event) => {
        const { value } = event.target;
        setSearch(event);
        if (onSearch) {
            onSearch(value);
        }
    };
    const availableOptions = options
        .filter(item => regexp.test(`${item.label || item.value}`))
        .map((option, index) => {
        const { disabled, label, prefix, suffix, value } = option;
        const isSelected = values.includes(option);
        const isHovered = cursor === index;
        return ((0, jsx_runtime_1.jsxs)(Item, { "data-component-name": "DropdownItem", disabled: disabled, hovered: isHovered, onClick: () => (isSelected ? removeItem(null, option, false) : addItem(option)), role: "listitem", selected: isSelected, shade: shade, variant: variant, children: [prefix && ((0, jsx_runtime_1.jsx)(Box_1.BoxInline, { "data-component-name": "DropdownOptionPrefix", mr: "xxs", children: prefix })), (0, jsx_runtime_1.jsx)(Box_1.BoxInline, { flex: "grow", children: label || value }), suffix && ((0, jsx_runtime_1.jsx)(Box_1.BoxInline, { "data-component-name": "DropdownOptionSuffix", ml: "xxs", children: suffix }))] }, option.value));
    });
    const output = {
        options: availableOptions,
    };
    if (children && !availableOptions.length) {
        output.create = (0, jsx_runtime_1.jsx)(Centered, { withBorder: !!availableOptions.length, children: children });
    }
    if (!children && !availableOptions.length) {
        output.options = (0, jsx_runtime_1.jsx)(Empty, { children: getLabels().noData });
    }
    return ((0, jsx_runtime_1.jsxs)(List, { "data-component-name": "DropdownOptions", maxHeight: getStyles().menuMaxHeight, children: [searchable && ((0, jsx_runtime_1.jsx)(Search, { "data-component-name": "DropdownOptionsSearch", children: (0, jsx_runtime_1.jsx)(Input, { ref: searchInput, onChange: handleSearch, shade: shade, type: "text", value: search, variant: variant }) })), (0, jsx_runtime_1.jsx)(Items, { "data-component-name": "DropdownOptionsList", children: output.options }), output.create] }));
}
exports.default = DropdownOptions;
//# sourceMappingURL=Items.js.map