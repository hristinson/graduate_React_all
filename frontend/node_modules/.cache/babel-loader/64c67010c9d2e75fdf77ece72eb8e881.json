{"ast":null,"code":"import hex2hsl from './hex2hsl';\nimport hex2rgb from './hex2rgb';\nimport hsl2hex from './hsl2hex';\nimport hsl2rgb from './hsl2rgb';\nimport isValidHex from './is-valid-hex';\nimport { cssColors } from './modules/css-colors';\nimport { invariant, isString, messages } from './modules/utils';\nimport rgb2hex from './rgb2hex';\nimport rgb2hsl from './rgb2hsl';\n/**\n * Parse CSS color\n */\n\nexport default function parseCSS(input, output) {\n  invariant(isString(input), messages.inputString);\n  let result;\n  const parsedInput = cssColors[input.toLowerCase()] || input;\n\n  if (isValidHex(parsedInput)) {\n    switch (output) {\n      case 'hsl':\n        {\n          result = hex2hsl(parsedInput);\n          break;\n        }\n\n      case 'rgb':\n        {\n          result = hex2rgb(parsedInput);\n          break;\n        }\n\n      default:\n        {\n          result = parsedInput;\n          break;\n        }\n    }\n  } else {\n    // TODO: improve the pattern to require 3 groups\n    const matches = parsedInput.match(/(hsl|rgb)a?\\((\\d+)(?:,\\s*|\\s+)(\\d+)%?(?:,\\s*|\\s+)(\\d+)%?[^)]*\\)/i);\n    invariant(Array.isArray(matches), 'invalid CSS string');\n    invariant(matches.length === 5, 'invalid CSS string');\n    const [, model, hORr, sORg, lORb] = matches;\n    let hex;\n    let hsl;\n    let rgb;\n\n    if (model === 'hsl') {\n      hsl = {\n        h: parseInt(hORr, 10),\n        s: parseInt(sORg, 10),\n        l: parseInt(lORb, 10)\n      };\n      hex = hsl2hex(hsl);\n      rgb = hsl2rgb(hsl);\n    } else {\n      rgb = {\n        r: parseInt(hORr, 10),\n        g: parseInt(sORg, 10),\n        b: parseInt(lORb, 10)\n      };\n      hex = rgb2hex(rgb);\n      hsl = rgb2hsl(rgb);\n    }\n\n    switch (output) {\n      case 'hsl':\n        {\n          result = hsl;\n          break;\n        }\n\n      case 'rgb':\n        {\n          result = rgb;\n          break;\n        }\n\n      case 'hex':\n      default:\n        {\n          result = hex;\n          break;\n        }\n    }\n  }\n\n  return result;\n}","map":{"version":3,"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,UAAP,MAAuB,gBAAvB;AACA,SAASC,SAAT,QAA0B,sBAA1B;AACA,SAASC,SAAT,EAAoBC,QAApB,EAA8BC,QAA9B,QAA8C,iBAA9C;AACA,OAAOC,OAAP,MAAoB,WAApB;AACA,OAAOC,OAAP,MAAoB,WAApB;AAGA;;;;AAGA,eAAc,SAAUC,QAAV,CACZC,KADY,EAEZC,MAFY,EAEF;EAEVP,SAAS,CAACC,QAAQ,CAACK,KAAD,CAAT,EAAkBJ,QAAQ,CAACM,WAA3B,CAAT;EACA,IAAIC,MAAJ;EAEA,MAAMC,WAAW,GAAGX,SAAS,CAACO,KAAK,CAACK,WAAN,EAAD,CAAT,IAA4DL,KAAhF;;EAEA,IAAIR,UAAU,CAACY,WAAD,CAAd,EAA6B;IAC3B,QAAQH,MAAR;MACE,KAAK,KAAL;QAAY;UACVE,MAAM,GAAGf,OAAO,CAACgB,WAAD,CAAhB;UACA;QACD;;MACD,KAAK,KAAL;QAAY;UACVD,MAAM,GAAGd,OAAO,CAACe,WAAD,CAAhB;UACA;QACD;;MACD;QAAS;UACPD,MAAM,GAAGC,WAAT;UACA;QACD;IAZH;EAcD,CAfD,MAeO;IACL;IACA,MAAME,OAAO,GAAGF,WAAW,CAACG,KAAZ,CACd,kEADc,CAAhB;IAIAb,SAAS,CAACc,KAAK,CAACC,OAAN,CAAcH,OAAd,CAAD,EAAyB,oBAAzB,CAAT;IACAZ,SAAS,CAACY,OAAO,CAACI,MAAR,KAAmB,CAApB,EAAuB,oBAAvB,CAAT;IAEA,MAAM,GAAGC,KAAH,EAAUC,IAAV,EAAgBC,IAAhB,EAAsBC,IAAtB,IAA8BR,OAApC;IACA,IAAIS,GAAJ;IACA,IAAIC,GAAJ;IACA,IAAIC,GAAJ;;IAEA,IAAIN,KAAK,KAAK,KAAd,EAAqB;MACnBK,GAAG,GAAG;QACJE,CAAC,EAAEC,QAAQ,CAACP,IAAD,EAAO,EAAP,CADP;QAEJQ,CAAC,EAAED,QAAQ,CAACN,IAAD,EAAO,EAAP,CAFP;QAGJQ,CAAC,EAAEF,QAAQ,CAACL,IAAD,EAAO,EAAP;MAHP,CAAN;MAKAC,GAAG,GAAGzB,OAAO,CAAC0B,GAAD,CAAb;MACAC,GAAG,GAAG1B,OAAO,CAACyB,GAAD,CAAb;IACD,CARD,MAQO;MACLC,GAAG,GAAG;QACJK,CAAC,EAAEH,QAAQ,CAACP,IAAD,EAAO,EAAP,CADP;QAEJW,CAAC,EAAEJ,QAAQ,CAACN,IAAD,EAAO,EAAP,CAFP;QAGJW,CAAC,EAAEL,QAAQ,CAACL,IAAD,EAAO,EAAP;MAHP,CAAN;MAKAC,GAAG,GAAGlB,OAAO,CAACoB,GAAD,CAAb;MACAD,GAAG,GAAGlB,OAAO,CAACmB,GAAD,CAAb;IACD;;IAED,QAAQhB,MAAR;MACE,KAAK,KAAL;QAAY;UACVE,MAAM,GAAGa,GAAT;UACA;QACD;;MACD,KAAK,KAAL;QAAY;UACVb,MAAM,GAAGc,GAAT;UACA;QACD;;MAED,KAAK,KAAL;MACA;QAAS;UACPd,MAAM,GAAGY,GAAT;UACA;QACD;IAdH;EAgBD;;EAED,OAAOZ,MAAP;AACD","names":["hex2hsl","hex2rgb","hsl2hex","hsl2rgb","isValidHex","cssColors","invariant","isString","messages","rgb2hex","rgb2hsl","parseCSS","input","output","inputString","result","parsedInput","toLowerCase","matches","match","Array","isArray","length","model","hORr","sORg","lORb","hex","hsl","rgb","h","parseInt","s","l","r","g","b"],"sources":["/My_WORK/graduate_React/frontend/node_modules/colorizr/src/parse-css.ts"],"sourcesContent":["import hex2hsl from './hex2hsl';\nimport hex2rgb from './hex2rgb';\nimport hsl2hex from './hsl2hex';\nimport hsl2rgb from './hsl2rgb';\nimport isValidHex from './is-valid-hex';\nimport { cssColors } from './modules/css-colors';\nimport { invariant, isString, messages } from './modules/utils';\nimport rgb2hex from './rgb2hex';\nimport rgb2hsl from './rgb2hsl';\nimport { ColorTypes, Return } from './types';\n\n/**\n * Parse CSS color\n */\nexport default function parseCSS<T extends ColorTypes = 'hex'>(\n  input: unknown,\n  output?: T,\n): Return<T> {\n  invariant(isString(input), messages.inputString);\n  let result: any;\n\n  const parsedInput = cssColors[input.toLowerCase() as keyof typeof cssColors] || input;\n\n  if (isValidHex(parsedInput)) {\n    switch (output) {\n      case 'hsl': {\n        result = hex2hsl(parsedInput);\n        break;\n      }\n      case 'rgb': {\n        result = hex2rgb(parsedInput);\n        break;\n      }\n      default: {\n        result = parsedInput;\n        break;\n      }\n    }\n  } else {\n    // TODO: improve the pattern to require 3 groups\n    const matches = parsedInput.match(\n      /(hsl|rgb)a?\\((\\d+)(?:,\\s*|\\s+)(\\d+)%?(?:,\\s*|\\s+)(\\d+)%?[^)]*\\)/i,\n    );\n\n    invariant(Array.isArray(matches), 'invalid CSS string');\n    invariant(matches.length === 5, 'invalid CSS string');\n\n    const [, model, hORr, sORg, lORb] = matches;\n    let hex;\n    let hsl;\n    let rgb;\n\n    if (model === 'hsl') {\n      hsl = {\n        h: parseInt(hORr, 10),\n        s: parseInt(sORg, 10),\n        l: parseInt(lORb, 10),\n      };\n      hex = hsl2hex(hsl);\n      rgb = hsl2rgb(hsl);\n    } else {\n      rgb = {\n        r: parseInt(hORr, 10),\n        g: parseInt(sORg, 10),\n        b: parseInt(lORb, 10),\n      };\n      hex = rgb2hex(rgb);\n      hsl = rgb2hsl(rgb);\n    }\n\n    switch (output) {\n      case 'hsl': {\n        result = hsl;\n        break;\n      }\n      case 'rgb': {\n        result = rgb;\n        break;\n      }\n\n      case 'hex':\n      default: {\n        result = hex;\n        break;\n      }\n    }\n  }\n\n  return result as Return<T>;\n}\n"]},"metadata":{},"sourceType":"module"}