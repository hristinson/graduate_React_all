{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport is from 'is-lite';\n/**\n * Get a random item from an array\n */\n\nexport function getRandomItem(input) {\n  return input[Math.floor(Math.random() * input.length)];\n}\n/**\n * Sort an array of numbers using a quick sort algorithm\n */\n\nexport function quickSort(input, comparator) {\n  if (comparator === void 0) {\n    comparator = sortComparator;\n  } // Create a sortable array to return.\n\n\n  var output = __spreadArray([], __read(input), false); // Recursively sort sub-arrays.\n\n\n  var recursiveSort = function (start, end) {\n    // If this sub-array is empty, it's sorted.\n    if (end - start < 1) {\n      return;\n    }\n\n    var pivotValue = output[end];\n    var splitIndex = start;\n\n    for (var index = start; index < end; index++) {\n      var sort = comparator(output[index], pivotValue); // This value is less than the pivot value.\n\n      if (sort === -1) {\n        // If the element just to the right of the split index,\n        //   isn't this element, swap them.\n        if (splitIndex !== index) {\n          var temp = output[splitIndex];\n          output[splitIndex] = output[index];\n          output[index] = temp;\n        } // Move the split index to the right by one,\n        //   denoting an increase in the less-than sub-array size.\n\n\n        splitIndex++;\n      } // Leave values that are greater than or equal to\n      //   the pivot value where they are.\n\n    } // Move the pivot value to between the split.\n\n\n    output[end] = output[splitIndex];\n    output[splitIndex] = pivotValue; // Recursively sort the less-than and greater-than arrays.\n\n    recursiveSort(start, splitIndex - 1);\n    recursiveSort(splitIndex + 1, end);\n  }; // Sort the entire array.\n\n\n  recursiveSort(0, input.length - 1);\n  return output;\n}\n/**\n * Sort an array with localeCompare\n */\n\nexport function sortByLocaleCompare(key, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var descending = options.descending,\n      compareOptions = __rest(options, [\"descending\"]);\n\n  if (key) {\n    if (descending) {\n      return function (left, right) {\n        return right[key].toLowerCase().localeCompare(left[key].toLowerCase(), undefined, compareOptions);\n      };\n    }\n\n    return function (left, right) {\n      return left[key].toLowerCase().localeCompare(right[key].toLowerCase(), undefined, compareOptions);\n    };\n  }\n\n  if (descending) {\n    return function (left, right) {\n      return right.toLowerCase().localeCompare(left.toLowerCase(), undefined, compareOptions);\n    };\n  }\n\n  return function (left, right) {\n    return left.toLowerCase().localeCompare(right.toLowerCase(), undefined, compareOptions);\n  };\n}\n/**\n * Sort an array by primitive values\n */\n\nexport function sortByPrimitive(key, descending) {\n  if (descending === void 0) {\n    descending = false;\n  }\n\n  var firstComparator = descending ? 1 : -1;\n  var secondComparator = descending ? -1 : 1;\n\n  if (key) {\n    return function (left, right) {\n      if (left[key] === right[key]) {\n        return 0;\n      }\n\n      return left[key] < right[key] ? firstComparator : secondComparator;\n    };\n  }\n\n  return function (left, right) {\n    if (left === right) {\n      return 0;\n    }\n\n    return left < right ? firstComparator : secondComparator;\n  };\n}\n/**\n * Basic sort comparator\n */\n\nexport function sortComparator(left, right) {\n  if (left < right) {\n    return -1;\n  }\n\n  if (left > right) {\n    return 1;\n  }\n\n  return 0;\n}\nexport function splitIntoChunks(input, chunkSize) {\n  if (chunkSize === void 0) {\n    chunkSize = 25;\n  }\n\n  if (!is.array(input)) {\n    throw new TypeError('expected an array for the first argument');\n  }\n\n  var chunks = [];\n\n  for (var index = 0; index < Math.ceil(input.length / chunkSize); index++) {\n    chunks.push(input.slice(index * chunkSize, (index + 1) * chunkSize));\n  }\n\n  return chunks;\n}","map":{"version":3,"mappings":"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","names":["is","getRandomItem","input","Math","floor","random","length","quickSort","comparator","output","recursiveSort","start","end","pivotValue","splitIndex","index","sort","temp","sortByLocaleCompare","key","options","compareOptions","descending","left","right","toLowerCase","localeCompare","undefined","sortByPrimitive","firstComparator","secondComparator","sortComparator","splitIntoChunks","chunkSize","array","TypeError","chunks","ceil","push","slice"],"sources":["/My_WORK/graduate_React/frontend/node_modules/@gilbarbara/helpers/src/arrays.ts"],"sourcesContent":["import { AnyObject, PlainObject } from '@gilbarbara/types';\nimport is from 'is-lite';\n\nimport { SortFunction } from './types';\n\n/**\n * Get a random item from an array\n */\nexport function getRandomItem(input: any[]) {\n  return input[Math.floor(Math.random() * input.length)];\n}\n\n/**\n * Sort an array of numbers using a quick sort algorithm\n */\nexport function quickSort<T extends string | number>(input: T[], comparator = sortComparator): T[] {\n  // Create a sortable array to return.\n  const output = [...input];\n\n  // Recursively sort sub-arrays.\n  const recursiveSort = (start: number, end: number) => {\n    // If this sub-array is empty, it's sorted.\n    if (end - start < 1) {\n      return;\n    }\n\n    const pivotValue = output[end];\n    let splitIndex = start;\n\n    for (let index = start; index < end; index++) {\n      const sort = comparator(output[index], pivotValue);\n\n      // This value is less than the pivot value.\n      if (sort === -1) {\n        // If the element just to the right of the split index,\n        //   isn't this element, swap them.\n        if (splitIndex !== index) {\n          const temp = output[splitIndex];\n\n          output[splitIndex] = output[index];\n          output[index] = temp;\n        }\n\n        // Move the split index to the right by one,\n        //   denoting an increase in the less-than sub-array size.\n        splitIndex++;\n      }\n\n      // Leave values that are greater than or equal to\n      //   the pivot value where they are.\n    }\n\n    // Move the pivot value to between the split.\n    output[end] = output[splitIndex];\n    output[splitIndex] = pivotValue;\n\n    // Recursively sort the less-than and greater-than arrays.\n    recursiveSort(start, splitIndex - 1);\n    recursiveSort(splitIndex + 1, end);\n  };\n\n  // Sort the entire array.\n  recursiveSort(0, input.length - 1);\n\n  return output;\n}\n\n/**\n * Sort an array with localeCompare\n */\nexport function sortByLocaleCompare(\n  key?: string,\n  options: Intl.CollatorOptions & { descending?: boolean } = {},\n): SortFunction {\n  const { descending, ...compareOptions } = options;\n\n  if (key) {\n    if (descending) {\n      return <T extends AnyObject>(left: PlainObject<T>, right: PlainObject<T>) =>\n        right[key].toLowerCase().localeCompare(left[key].toLowerCase(), undefined, compareOptions);\n    }\n\n    return <T extends AnyObject>(left: PlainObject<T>, right: PlainObject<T>) =>\n      left[key].toLowerCase().localeCompare(right[key].toLowerCase(), undefined, compareOptions);\n  }\n\n  if (descending) {\n    return <T extends string>(left: T, right: T) =>\n      right.toLowerCase().localeCompare(left.toLowerCase(), undefined, compareOptions);\n  }\n\n  return <T extends string>(left: T, right: T) =>\n    left.toLowerCase().localeCompare(right.toLowerCase(), undefined, compareOptions);\n}\n\n/**\n * Sort an array by primitive values\n */\nexport function sortByPrimitive<T extends number | boolean>(\n  key?: string,\n  descending = false,\n): SortFunction {\n  const firstComparator = descending ? 1 : -1;\n  const secondComparator = descending ? -1 : 1;\n\n  if (key) {\n    return <P extends AnyObject>(left: PlainObject<P>, right: PlainObject<P>) => {\n      if (left[key] === right[key]) {\n        return 0;\n      }\n\n      return left[key] < right[key] ? firstComparator : secondComparator;\n    };\n  }\n\n  return <P extends T>(left: P, right: P) => {\n    if (left === right) {\n      return 0;\n    }\n\n    return left < right ? firstComparator : secondComparator;\n  };\n}\n\n/**\n * Basic sort comparator\n */\nexport function sortComparator(left: string | number, right: string | number) {\n  if (left < right) {\n    return -1;\n  }\n\n  if (left > right) {\n    return 1;\n  }\n\n  return 0;\n}\n\nexport function splitIntoChunks<T>(input: T[], chunkSize: number = 25): T[][] {\n  if (!is.array(input)) {\n    throw new TypeError('expected an array for the first argument');\n  }\n\n  const chunks: T[][] = [];\n\n  for (let index = 0; index < Math.ceil(input.length / chunkSize); index++) {\n    chunks.push(input.slice(index * chunkSize, (index + 1) * chunkSize));\n  }\n\n  return chunks;\n}\n"]},"metadata":{},"sourceType":"module"}