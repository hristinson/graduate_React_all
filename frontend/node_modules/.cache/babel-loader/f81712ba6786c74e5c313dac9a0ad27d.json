{"ast":null,"code":"export const HSLKeys = ['h', 's', 'l'];\nexport const RGBKeys = ['r', 'g', 'b'];\n/**\n * Constrain value into the range\n */\n\nexport function constrain(input, amount, range, sign) {\n  invariant(arguments.length === 4, 'All parameters are required');\n  const [min, max] = range;\n  let value = expr(input + sign + amount);\n\n  if (value < min) {\n    value = min;\n  } else if (value > max) {\n    value = max;\n  }\n\n  return Math.abs(value);\n}\n/**\n * Constrain an angle\n */\n\nexport function constrainDegrees(input, amount) {\n  invariant(isNumber(input), 'input is required');\n  let value = input + amount;\n\n  if (value > 360) {\n    value %= 360;\n  }\n\n  if (value < 0) {\n    value += 360;\n  }\n\n  return Math.abs(value);\n}\n/**\n * Parse math string expressions\n */\n\nexport function expr(input) {\n  const chars = [...input];\n  const n = [];\n  const op = [];\n  let parsed;\n  let index = 0;\n  let last = true;\n  n[index] = ''; // Parse the string\n\n  for (const char of chars) {\n    if (Number.isNaN(parseInt(char, 10)) && char !== '.' && !last) {\n      op[index] = char;\n      index++;\n      n[index] = '';\n      last = true;\n    } else {\n      n[index] += char;\n      last = false;\n    }\n  } // Calculate the expression\n\n\n  parsed = parseFloat(n[0]);\n\n  for (const [o, element] of op.entries()) {\n    const value = parseFloat(n[o + 1]);\n\n    switch (element) {\n      case '+':\n        parsed += value;\n        break;\n\n      case '-':\n        parsed -= value;\n        break;\n\n      case '*':\n        parsed *= value;\n        break;\n\n      case '/':\n        parsed /= value;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return parsed;\n}\nexport function invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n  /* istanbul ignore else */\n\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (message === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  let error;\n\n  if (!message) {\n    throw new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n  } else {\n    error = new Error(message);\n  }\n\n  error.name = 'colorizr';\n  throw error;\n}\n/**\n * Check if an object contains HSL values\n */\n\nexport function isHSL(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(_ref => {\n    let [key, value] = _ref;\n    return HSLKeys.includes(key) && value >= 0 && value <= (key === 'h' ? 360 : 100);\n  });\n}\n/**\n * Check if the input is a number and not NaN\n */\n\nexport function isNumber(input) {\n  return typeof input === 'number' && !Number.isNaN(input);\n}\n/**\n * Check if the input is an object\n */\n\nexport function isPlainObject(input) {\n  if (!input) {\n    return false;\n  }\n\n  const {\n    toString\n  } = Object.prototype;\n  const prototype = Object.getPrototypeOf(input);\n  return toString.call(input) === '[object Object]' && (prototype === null || prototype === Object.getPrototypeOf({}));\n}\n/**\n * Check if an object contains RGB values.\n */\n\nexport function isRGB(input) {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n  return !!entries.length && entries.every(_ref2 => {\n    let [key, value] = _ref2;\n    return RGBKeys.includes(key) && value >= 0 && value <= 255;\n  });\n}\n/**\n * Check if an array contains RGB values.\n */\n\nexport function isRGBArray(input) {\n  return Array.isArray(input) && input.length === 3 && input.every(d => d >= 0 && d <= 255);\n}\n/**\n * Check if the input is a string\n */\n\nexport function isString(input) {\n  return typeof input === 'string';\n}\n/**\n * Limit values per type.\n */\n\nexport function limit(input, type) {\n  invariant(isNumber(input), 'Input is not a number');\n  /* istanbul ignore else */\n\n  if (RGBKeys.includes(type)) {\n    return Math.max(Math.min(input, 255), 0);\n  }\n\n  if (['s', 'l'].includes(type)) {\n    return Math.max(Math.min(input, 100), 0);\n  }\n\n  if (type === 'h') {\n    return Math.max(Math.min(input, 360), 0);\n  }\n\n  throw new Error('Invalid type');\n}\nexport const messages = {\n  amount: 'amount must be a number',\n  left: 'left is required and must be a string',\n  right: 'right is required and must be a string',\n  input: 'input is required',\n  inputString: 'input is required and must be a string',\n  invalid: 'invalid input',\n  options: 'invalid options'\n};\n/**\n * Creates an object composed of the picked source properties.\n */\n\nexport function pick(input, options) {\n  if (!Array.isArray(options)) {\n    throw new TypeError('options must be an array');\n  }\n\n  return options.filter(d => typeof input[d] !== 'undefined').reduce((acc, d) => {\n    acc[d] = input[d];\n    return acc;\n  }, {});\n}\n/**\n * Round decimal numbers.\n */\n\nexport function round(input) {\n  let digits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  const factor = 10 ** digits;\n  return Math.round(input * factor) / factor;\n}","map":{"version":3,"mappings":"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","names":["HSLKeys","RGBKeys","constrain","input","amount","range","sign","invariant","arguments","length","min","max","value","expr","Math","abs","constrainDegrees","isNumber","chars","n","op","parsed","index","last","char","Number","isNaN","parseInt","parseFloat","o","element","entries","condition","message","process","env","NODE_ENV","undefined","Error","error","name","isHSL","isPlainObject","Object","every","key","includes","toString","prototype","getPrototypeOf","call","isRGB","isRGBArray","Array","isArray","d","isString","limit","type","messages","left","right","inputString","invalid","options","pick","TypeError","filter","reduce","acc","round","digits","factor"],"sources":["/My_WORK/graduate_React/frontend/node_modules/colorizr/src/modules/utils.ts"],"sourcesContent":["import { HSL, PlainObject, RGB, RGBArray } from '../types';\n\nexport const HSLKeys = ['h', 's', 'l'];\nexport const RGBKeys = ['r', 'g', 'b'];\n\n/**\n * Constrain value into the range\n */\nexport function constrain(input: number, amount: number, range: number[], sign: string): number {\n  invariant(arguments.length === 4, 'All parameters are required');\n\n  const [min, max] = range;\n  let value = expr(input + sign + amount);\n\n  if (value < min) {\n    value = min;\n  } else if (value > max) {\n    value = max;\n  }\n\n  return Math.abs(value);\n}\n\n/**\n * Constrain an angle\n */\nexport function constrainDegrees(input: number, amount: number): number {\n  invariant(isNumber(input), 'input is required');\n\n  let value = input + amount;\n\n  if (value > 360) {\n    value %= 360;\n  }\n\n  if (value < 0) {\n    value += 360;\n  }\n\n  return Math.abs(value);\n}\n\n/**\n * Parse math string expressions\n */\nexport function expr(input: string): number {\n  const chars = [...input];\n  const n: string[] = [];\n  const op: string[] = [];\n\n  let parsed;\n  let index = 0;\n  let last = true;\n\n  n[index] = '';\n\n  // Parse the string\n  for (const char of chars) {\n    if (Number.isNaN(parseInt(char, 10)) && char !== '.' && !last) {\n      op[index] = char;\n      index++;\n      n[index] = '';\n      last = true;\n    } else {\n      n[index] += char;\n      last = false;\n    }\n  }\n\n  // Calculate the expression\n  parsed = parseFloat(n[0]);\n\n  for (const [o, element] of op.entries()) {\n    const value = parseFloat(n[o + 1]);\n\n    switch (element) {\n      case '+':\n        parsed += value;\n        break;\n      case '-':\n        parsed -= value;\n        break;\n      case '*':\n        parsed *= value;\n        break;\n      case '/':\n        parsed /= value;\n        break;\n      default:\n        break;\n    }\n  }\n\n  return parsed;\n}\n\nexport function invariant(condition: boolean, message: string): asserts condition {\n  if (condition) {\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    if (message === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  let error;\n\n  if (!message) {\n    throw new Error(\n      'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.',\n    );\n  } else {\n    error = new Error(message);\n  }\n\n  error.name = 'colorizr';\n\n  throw error;\n}\n\n/**\n * Check if an object contains HSL values\n */\nexport function isHSL(input: any): input is HSL {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n\n  return (\n    !!entries.length &&\n    entries.every(\n      ([key, value]) => HSLKeys.includes(key) && value >= 0 && value <= (key === 'h' ? 360 : 100),\n    )\n  );\n}\n\n/**\n * Check if the input is a number and not NaN\n */\nexport function isNumber(input: any): input is number {\n  return typeof input === 'number' && !Number.isNaN(input);\n}\n\n/**\n * Check if the input is an object\n */\nexport function isPlainObject(input: any): input is PlainObject {\n  if (!input) {\n    return false;\n  }\n\n  const { toString } = Object.prototype;\n  const prototype = Object.getPrototypeOf(input);\n\n  return (\n    toString.call(input) === '[object Object]' &&\n    (prototype === null || prototype === Object.getPrototypeOf({}))\n  );\n}\n\n/**\n * Check if an object contains RGB values.\n */\nexport function isRGB(input: any): input is RGB {\n  if (!isPlainObject(input)) {\n    return false;\n  }\n\n  const entries = Object.entries(input);\n\n  return (\n    !!entries.length &&\n    entries.every(([key, value]) => RGBKeys.includes(key) && value >= 0 && value <= 255)\n  );\n}\n\n/**\n * Check if an array contains RGB values.\n */\nexport function isRGBArray(input: any): input is RGBArray {\n  return Array.isArray(input) && input.length === 3 && input.every(d => d >= 0 && d <= 255);\n}\n\n/**\n * Check if the input is a string\n */\nexport function isString(input: any): input is string {\n  return typeof input === 'string';\n}\n\n/**\n * Limit values per type.\n */\nexport function limit(input: number, type: string): number {\n  invariant(isNumber(input), 'Input is not a number');\n\n  /* istanbul ignore else */\n  if (RGBKeys.includes(type)) {\n    return Math.max(Math.min(input, 255), 0);\n  }\n\n  if (['s', 'l'].includes(type)) {\n    return Math.max(Math.min(input, 100), 0);\n  }\n\n  if (type === 'h') {\n    return Math.max(Math.min(input, 360), 0);\n  }\n\n  throw new Error('Invalid type');\n}\n\nexport const messages = {\n  amount: 'amount must be a number',\n  left: 'left is required and must be a string',\n  right: 'right is required and must be a string',\n  input: 'input is required',\n  inputString: 'input is required and must be a string',\n  invalid: 'invalid input',\n  options: 'invalid options',\n};\n\n/**\n * Creates an object composed of the picked source properties.\n */\nexport function pick(input: PlainObject, options: string[]): PlainObject {\n  if (!Array.isArray(options)) {\n    throw new TypeError('options must be an array');\n  }\n\n  return options\n    .filter(d => typeof input[d] !== 'undefined')\n    .reduce((acc: PlainObject, d) => {\n      acc[d] = input[d];\n\n      return acc;\n    }, {});\n}\n\n/**\n * Round decimal numbers.\n */\nexport function round(input: number, digits = 2): number {\n  const factor = 10 ** digits;\n\n  return Math.round(input * factor) / factor;\n}\n"]},"metadata":{},"sourceType":"module"}