{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nimport { useCallback, useEffect, useRef, useState } from 'react';\n\nfunction useEffectOnce(effect) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(effect, []);\n}\n\nexport function useMount(effect) {\n  useEffectOnce(effect);\n}\nexport function useSetState(initialState) {\n  if (initialState === void 0) {\n    initialState = {};\n  }\n\n  var _a = __read(useState(initialState), 2),\n      state = _a[0],\n      set = _a[1];\n\n  var setState = useCallback(function (patch) {\n    set(function (previousState) {\n      return __assign(__assign({}, previousState), patch instanceof Function ? patch(previousState) : patch);\n    });\n  }, [set]);\n  return [state, setState];\n}\nexport function useSingleton(callback) {\n  var hasBeenCalled = useRef(false);\n\n  if (hasBeenCalled.current) {\n    return;\n  }\n\n  callback();\n  hasBeenCalled.current = true;\n}\nexport function useUnmount(fn) {\n  var fnRef = useRef(fn); // update the ref each render so if it change the newest callback will be invoked\n\n  fnRef.current = fn; // eslint-disable-next-line unicorn/consistent-function-scoping\n\n  useEffectOnce(function () {\n    return function () {\n      return fnRef.current();\n    };\n  });\n}\nexport function useUpdateEffect(effect, deps) {\n  var isFirst = useRef(true);\n  useEffect(function () {\n    if (!isFirst.current) {\n      effect();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, deps);\n\n  if (isFirst.current) {\n    isFirst.current = false;\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAyCA,WAAzC,EAAsDC,SAAtD,EAAiEC,MAAjE,EAAyEC,QAAzE,QAAyF,OAAzF;;AAGA,SAASC,aAAT,CAAuBC,MAAvB,EAA6C;EAC3C;EACAJ,SAAS,CAACI,MAAD,EAAS,EAAT,CAAT;AACD;;AAED,OAAM,SAAUC,QAAV,CAAmBD,MAAnB,EAAyC;EAC7CD,aAAa,CAACC,MAAD,CAAb;AACD;AAED,OAAM,SAAUE,WAAV,CACJC,YADI,EACqB;EAAzB;IAAAA,eAAkB,EAAlB;EAAyB;;EAEnB,gBAAeL,QAAQ,CAAIK,YAAJ,CAAvB,EAAwC,CAAxC;EAAA,IAACC,KAAK,QAAN;EAAA,IAAQC,GAAG,QAAX;;EAEN,IAAMC,QAAQ,GAAGX,WAAW,CAC1B,UAACY,KAAD,EAAuD;IACrDF,GAAG,CAAC,yBAAa;MAAI,6BAChBG,aADgB,GAEfD,KAAK,YAAYE,QAAjB,GAA4BF,KAAK,CAACC,aAAD,CAAjC,GAAmDD,KAFpC;IAGnB,CAHC,CAAH;EAID,CANyB,EAO1B,CAACF,GAAD,CAP0B,CAA5B;EAUA,OAAO,CAACD,KAAD,EAAQE,QAAR,CAAP;AACD;AAED,OAAM,SAAUI,YAAV,CAAuBC,QAAvB,EAA2C;EAC/C,IAAMC,aAAa,GAAGf,MAAM,CAAC,KAAD,CAA5B;;EAEA,IAAIe,aAAa,CAACC,OAAlB,EAA2B;IACzB;EACD;;EAEDF,QAAQ;EACRC,aAAa,CAACC,OAAd,GAAwB,IAAxB;AACD;AAED,OAAM,SAAUC,UAAV,CAAqBC,EAArB,EAAkC;EACtC,IAAMC,KAAK,GAAGnB,MAAM,CAACkB,EAAD,CAApB,CADsC,CAGtC;;EACAC,KAAK,CAACH,OAAN,GAAgBE,EAAhB,CAJsC,CAMtC;;EACAhB,aAAa,CAAC;IAAM;MAAM,YAAK,CAACc,OAAN;IAAe,CAArB;EAAqB,CAA5B,CAAb;AACD;AAED,OAAM,SAAUI,eAAV,CAA0BjB,MAA1B,EAAkDkB,IAAlD,EAAuE;EAC3E,IAAMC,OAAO,GAAGtB,MAAM,CAAC,IAAD,CAAtB;EAEAD,SAAS,CAAC;IACR,IAAI,CAACuB,OAAO,CAACN,OAAb,EAAsB;MACpBb,MAAM;IACP,CAHO,CAIR;;EACD,CALQ,EAKNkB,IALM,CAAT;;EAOA,IAAIC,OAAO,CAACN,OAAZ,EAAqB;IACnBM,OAAO,CAACN,OAAR,GAAkB,KAAlB;EACD;AACF","names":["useCallback","useEffect","useRef","useState","useEffectOnce","effect","useMount","useSetState","initialState","state","set","setState","patch","previousState","Function","useSingleton","callback","hasBeenCalled","current","useUnmount","fn","fnRef","useUpdateEffect","deps","isFirst"],"sources":["/My_WORK/graduate_React/frontend/node_modules/react-floater/src/modules/hooks.ts"],"sourcesContent":["import { DependencyList, EffectCallback, useCallback, useEffect, useRef, useState } from 'react';\nimport { AnyObject } from '@gilbarbara/types';\n\nfunction useEffectOnce(effect: EffectCallback) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(effect, []);\n}\n\nexport function useMount(effect: EffectCallback) {\n  useEffectOnce(effect);\n}\n\nexport function useSetState<T extends AnyObject>(\n  initialState: T = {} as T,\n): [T, (patch: Partial<T> | ((previousState: T) => Partial<T>)) => void] {\n  const [state, set] = useState<T>(initialState);\n\n  const setState = useCallback(\n    (patch: Partial<T> | ((previousState: T) => Partial<T>)) => {\n      set(previousState => ({\n        ...previousState,\n        ...(patch instanceof Function ? patch(previousState) : patch),\n      }));\n    },\n    [set],\n  );\n\n  return [state, setState];\n}\n\nexport function useSingleton(callback: () => void): void {\n  const hasBeenCalled = useRef(false);\n\n  if (hasBeenCalled.current) {\n    return;\n  }\n\n  callback();\n  hasBeenCalled.current = true;\n}\n\nexport function useUnmount(fn: () => any): void {\n  const fnRef = useRef(fn);\n\n  // update the ref each render so if it change the newest callback will be invoked\n  fnRef.current = fn;\n\n  // eslint-disable-next-line unicorn/consistent-function-scoping\n  useEffectOnce(() => () => fnRef.current());\n}\n\nexport function useUpdateEffect(effect: EffectCallback, deps?: DependencyList) {\n  const isFirst = useRef(true);\n\n  useEffect(() => {\n    if (!isFirst.current) {\n      effect();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, deps);\n\n  if (isFirst.current) {\n    isFirst.current = false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}