{"ast":null,"code":"import { keyframes } from '@emotion/react';\nimport * as scroll from 'scroll';\nimport * as baseTheme from './theme';\nexport function animateIcon(target) {\n  let color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'primary';\n  let theme = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : baseTheme;\n  const {\n    black,\n    colors,\n    gray,\n    white\n  } = theme;\n  /* istanbul ignore else */\n\n  if (target) {\n    const icon = target.querySelector('[data-component-name=\"Icon\"]');\n\n    if (!icon) {\n      return;\n    }\n\n    const getColor = variant => {\n      switch (variant) {\n        case 'black':\n          {\n            return black;\n          }\n\n        case 'white':\n          {\n            return white;\n          }\n\n        case 'gray':\n          {\n            return gray;\n          }\n        // No default\n      }\n\n      return colors[variant];\n    };\n\n    const iconClone = document.createElement('span');\n    iconClone.innerHTML = icon.innerHTML;\n    iconClone.classList.add(icon.className, 'will-animate');\n    iconClone.setAttribute('style', `color: ${getColor(color)}; position: absolute; top: ${icon.offsetTop}px; left: ${icon.offsetLeft}px`);\n    target.appendChild(iconClone);\n    setTimeout(() => {\n      iconClone.classList.add('is-animating');\n    }, 100);\n    target.addEventListener('transitionend', () => {\n      /* istanbul ignore else */\n      if (iconClone.parentNode !== null && iconClone.classList.contains('is-animating')) {\n        iconClone.parentNode.removeChild(iconClone);\n      }\n    });\n  }\n}\nexport const fadeIn = keyframes`\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n`;\nexport const fadeOut = keyframes`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`;\nexport const fadeInOut = keyframes`\n  0% {\n    opacity: 0;\n  }\n\n  50% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`;\nexport const rotate = keyframes`\n  100% {\n    transform: rotate(360deg);\n  }\n`;\nexport function scrollDocument() {\n  return document.scrollingElement || document.createElement('body');\n}\nexport function scrollTo(value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    element = scrollDocument(),\n    scrollDuration = 400\n  } = options;\n  return new Promise((resolve, reject) => {\n    const {\n      scrollTop\n    } = element;\n    const nextValue = scrollDocument().scrollTop + value;\n    const limit = nextValue > scrollTop ? nextValue - scrollTop : scrollTop - nextValue;\n    scroll.top(element, nextValue, {\n      duration: limit < 100 ? 50 : scrollDuration\n    }, error => {\n      if (error && error.message !== 'Element already at target scroll position') {\n        return reject(error);\n      }\n\n      return resolve();\n    });\n  });\n}","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,QAA0B,gBAA1B;AACA,OAAO,KAAKC,MAAZ,MAAwB,QAAxB;AAEA,OAAO,KAAKC,SAAZ,MAA2B,SAA3B;AASA,OAAM,SAAUC,WAAV,CACJC,MADI,EAGoB;EAAA,IADxBC,KACwB,uEADN,SACM;EAAA,IAAxBC,KAAwB,uEAATJ,SAAS;EAExB,MAAM;IAAEK,KAAF;IAASC,MAAT;IAAiBC,IAAjB;IAAuBC;EAAvB,IAAiCJ,KAAvC;EAEA;;EACA,IAAIF,MAAJ,EAAY;IACV,MAAMO,IAAI,GAAGP,MAAM,CAACQ,aAAP,CAAqB,8BAArB,CAAb;;IAEA,IAAI,CAACD,IAAL,EAAW;MACT;IACD;;IAED,MAAME,QAAQ,GAAIC,OAAD,IAAsB;MACrC,QAAQA,OAAR;QACE,KAAK,OAAL;UAAc;YACZ,OAAOP,KAAP;UACD;;QACD,KAAK,OAAL;UAAc;YACZ,OAAOG,KAAP;UACD;;QACD,KAAK,MAAL;UAAa;YACX,OAAOD,IAAP;UACD;QACD;MAVF;;MAaA,OAAOD,MAAM,CAACM,OAAD,CAAb;IACD,CAfD;;IAiBA,MAAMC,SAAS,GAAGC,QAAQ,CAACC,aAAT,CAAuB,MAAvB,CAAlB;IAEAF,SAAS,CAACG,SAAV,GAAsBP,IAAI,CAACO,SAA3B;IACAH,SAAS,CAACI,SAAV,CAAoBC,GAApB,CAAwBT,IAAI,CAACU,SAA7B,EAAwC,cAAxC;IACAN,SAAS,CAACO,YAAV,CACE,OADF,EAEE,UAAUT,QAAQ,CAACR,KAAD,CAAO,8BAA8BM,IAAI,CAACY,SAAS,aACnEZ,IAAI,CAACa,UACP,IAJF;IAMApB,MAAM,CAACqB,WAAP,CAAmBV,SAAnB;IAEAW,UAAU,CAAC,MAAK;MACdX,SAAS,CAACI,SAAV,CAAoBC,GAApB,CAAwB,cAAxB;IACD,CAFS,EAEP,GAFO,CAAV;IAIAhB,MAAM,CAACuB,gBAAP,CAAwB,eAAxB,EAAyC,MAAK;MAC5C;MACA,IAAIZ,SAAS,CAACa,UAAV,KAAyB,IAAzB,IAAiCb,SAAS,CAACI,SAAV,CAAoBU,QAApB,CAA6B,cAA7B,CAArC,EAAmF;QACjFd,SAAS,CAACa,UAAV,CAAqBE,WAArB,CAAiCf,SAAjC;MACD;IACF,CALD;EAMD;AACF;AAED,OAAO,MAAMgB,MAAM,GAAG/B,SAAS;;;;;;;;CAAxB;AAUP,OAAO,MAAMgC,OAAO,GAAGhC,SAAS;;;;;;;;CAAzB;AAUP,OAAO,MAAMiC,SAAS,GAAGjC,SAAS;;;;;;;;;;;;CAA3B;AAcP,OAAO,MAAMkC,MAAM,GAAGlC,SAAS;;;;CAAxB;AAMP,OAAM,SAAUmC,cAAV,GAAwB;EAC5B,OAAQnB,QAAQ,CAACoB,gBAAT,IAA6CpB,QAAQ,CAACC,aAAT,CAAuB,MAAvB,CAArD;AACD;AAED,OAAM,SAAUoB,QAAV,CAAmBC,KAAnB,EAA+D;EAAA,IAA7BC,OAA6B,uEAAF,EAAE;EACnE,MAAM;IAAEC,OAAO,GAAGL,cAAc,EAA1B;IAA8BM,cAAc,GAAG;EAA/C,IAAuDF,OAA7D;EAEA,OAAO,IAAIG,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;IACrC,MAAM;MAAEC;IAAF,IAAgBL,OAAtB;IAEA,MAAMM,SAAS,GAAGX,cAAc,GAAGU,SAAjB,GAA6BP,KAA/C;IACA,MAAMS,KAAK,GAAGD,SAAS,GAAGD,SAAZ,GAAwBC,SAAS,GAAGD,SAApC,GAAgDA,SAAS,GAAGC,SAA1E;IAEA7C,MAAM,CAAC+C,GAAP,CACER,OADF,EAEEM,SAFF,EAGE;MAAEG,QAAQ,EAAEF,KAAK,GAAG,GAAR,GAAc,EAAd,GAAmBN;IAA/B,CAHF,EAIGS,KAAD,IAAe;MACb,IAAIA,KAAK,IAAIA,KAAK,CAACC,OAAN,KAAkB,2CAA/B,EAA4E;QAC1E,OAAOP,MAAM,CAACM,KAAD,CAAb;MACD;;MAED,OAAOP,OAAO,EAAd;IACD,CAVH;EAYD,CAlBM,CAAP;AAmBD","names":["keyframes","scroll","baseTheme","animateIcon","target","color","theme","black","colors","gray","white","icon","querySelector","getColor","variant","iconClone","document","createElement","innerHTML","classList","add","className","setAttribute","offsetTop","offsetLeft","appendChild","setTimeout","addEventListener","parentNode","contains","removeChild","fadeIn","fadeOut","fadeInOut","rotate","scrollDocument","scrollingElement","scrollTo","value","options","element","scrollDuration","Promise","resolve","reject","scrollTop","nextValue","limit","top","duration","error","message"],"sources":["/My_WORK/graduate_React/frontend/node_modules/@gilbarbara/components/src/modules/animations.ts"],"sourcesContent":["import { keyframes } from '@emotion/react';\nimport * as scroll from 'scroll';\n\nimport * as baseTheme from './theme';\n\nimport { Theme, Variants } from '../types';\n\ninterface ScrollToOptions {\n  element?: HTMLElement;\n  scrollDuration?: number;\n}\n\nexport function animateIcon(\n  target: HTMLElement,\n  color: Variants = 'primary',\n  theme: Theme = baseTheme,\n) {\n  const { black, colors, gray, white } = theme;\n\n  /* istanbul ignore else */\n  if (target) {\n    const icon = target.querySelector('[data-component-name=\"Icon\"]') as HTMLSpanElement;\n\n    if (!icon) {\n      return;\n    }\n\n    const getColor = (variant: Variants) => {\n      switch (variant) {\n        case 'black': {\n          return black;\n        }\n        case 'white': {\n          return white;\n        }\n        case 'gray': {\n          return gray;\n        }\n        // No default\n      }\n\n      return colors[variant];\n    };\n\n    const iconClone = document.createElement('span');\n\n    iconClone.innerHTML = icon.innerHTML;\n    iconClone.classList.add(icon.className, 'will-animate');\n    iconClone.setAttribute(\n      'style',\n      `color: ${getColor(color)}; position: absolute; top: ${icon.offsetTop}px; left: ${\n        icon.offsetLeft\n      }px`,\n    );\n    target.appendChild(iconClone);\n\n    setTimeout(() => {\n      iconClone.classList.add('is-animating');\n    }, 100);\n\n    target.addEventListener('transitionend', () => {\n      /* istanbul ignore else */\n      if (iconClone.parentNode !== null && iconClone.classList.contains('is-animating')) {\n        iconClone.parentNode.removeChild(iconClone);\n      }\n    });\n  }\n}\n\nexport const fadeIn = keyframes`\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n`;\n\nexport const fadeOut = keyframes`\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`;\n\nexport const fadeInOut = keyframes`\n  0% {\n    opacity: 0;\n  }\n\n  50% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n`;\n\nexport const rotate = keyframes`\n  100% {\n    transform: rotate(360deg);\n  }\n`;\n\nexport function scrollDocument(): HTMLElement {\n  return (document.scrollingElement as HTMLElement) || document.createElement('body');\n}\n\nexport function scrollTo(value: number, options: ScrollToOptions = {}): Promise<void> {\n  const { element = scrollDocument(), scrollDuration = 400 } = options;\n\n  return new Promise((resolve, reject) => {\n    const { scrollTop } = element;\n\n    const nextValue = scrollDocument().scrollTop + value;\n    const limit = nextValue > scrollTop ? nextValue - scrollTop : scrollTop - nextValue;\n\n    scroll.top(\n      element,\n      nextValue,\n      { duration: limit < 100 ? 50 : scrollDuration },\n      (error: any) => {\n        if (error && error.message !== 'Element already at target scroll position') {\n          return reject(error);\n        }\n\n        return resolve();\n      },\n    );\n  });\n}\n"]},"metadata":{},"sourceType":"module"}