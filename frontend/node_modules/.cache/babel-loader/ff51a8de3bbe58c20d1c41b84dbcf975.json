{"ast":null,"code":"var __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nimport is from 'is-lite';\n/**\n * Remove properties with undefined or empty string value from an object\n */\n\nexport function cleanUpObject(input) {\n  return Object.fromEntries(Object.entries(input).filter(function (_a) {\n    var _b = __read(_a, 2),\n        _ = _b[0],\n        v = _b[1];\n\n    return ![undefined, ''].includes(v);\n  }));\n}\n/**\n * Get a nested property inside an object or array\n */\n\nexport function getNestedProperty(input, path) {\n  if (!is.plainObject(input) && !is.array(input) || !path) {\n    return input;\n  }\n\n  var segments = path.split('.');\n  var length = segments.length;\n  var output = input;\n\n  var _loop_1 = function (index) {\n    var currentSegment = segments[index];\n    var remainingSegments = segments.slice(index + 1);\n\n    if (currentSegment === '+' && is.array(output) && remainingSegments.length === 1) {\n      return {\n        value: output.map(function (d) {\n          return d[remainingSegments.join('.')];\n        })\n      };\n    }\n\n    try {\n      output = output[currentSegment];\n    } catch (_a) {// skip\n    }\n  };\n\n  for (var index = 0; index < length; index++) {\n    var state_1 = _loop_1(index);\n\n    if (typeof state_1 === \"object\") return state_1.value;\n  }\n\n  return output;\n}\n/**\n * Invert object key and value\n */\n\nexport function invertKeys(input) {\n  var e_1, _a;\n\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  var result = {};\n\n  try {\n    // eslint-disable-next-line no-restricted-syntax\n    for (var _b = __values(Object.entries(input)), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var _d = __read(_c.value, 2),\n          key = _d[0],\n          value = _d[1];\n\n      result[value] = key;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return result;\n}\n/**\n * Set the key as the value\n */\n\nexport function keyMirror(input) {\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  var output = {}; // eslint-disable-next-line no-restricted-syntax\n\n  for (var key in input) {\n    /* istanbul ignore else */\n    if (!Object.prototype.hasOwnProperty.call(output, key)) {\n      output[key] = key;\n    }\n  }\n\n  return output;\n}\n/**\n * Convert an object to an array of objects\n */\n\nexport function objectToArray(input, includeOnly) {\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  return Object.entries(input).filter(function (_a) {\n    var _b = __read(_a, 2),\n        value = _b[1];\n\n    return includeOnly ? typeof value === \"\".concat(includeOnly) : true;\n  }) // eslint-disable-line valid-typeof\n  .map(function (_a) {\n    var _b;\n\n    var _c = __read(_a, 2),\n        key = _c[0],\n        value = _c[1];\n\n    return _b = {}, _b[key] = value, _b;\n  });\n}\n/**\n * Remove properties from an object\n */\n\nexport function omit(input) {\n  var filter = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    filter[_i - 1] = arguments[_i];\n  }\n\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  var output = {}; // eslint-disable-next-line no-restricted-syntax\n\n  for (var key in input) {\n    /* istanbul ignore else */\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n\n  return output;\n}\n/**\n * Select properties from an object\n */\n\nexport function pick(input) {\n  var filter = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    filter[_i - 1] = arguments[_i];\n  }\n\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  if (!filter.length) {\n    return input;\n  }\n\n  var output = {}; // eslint-disable-next-line no-restricted-syntax\n\n  for (var key in input) {\n    /* istanbul ignore else */\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n\n  return output;\n}\n/**\n * Stringify a shallow object into a query string\n */\n\nexport function queryStringFormat(input, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.addPrefix,\n      addPrefix = _a === void 0 ? false : _a,\n      _b = options.encodeValuesOnly,\n      encodeValuesOnly = _b === void 0 ? true : _b,\n      _c = options.encoder,\n      encoder = _c === void 0 ? encodeURIComponent : _c;\n\n  if (!is.plainObject(input)) {\n    throw new TypeError(\"input type isn't supported\");\n  }\n\n  var isValidInput = Object.values(input).every(function (item) {\n    if (is.array(item)) {\n      return item.every(function (d) {\n        return is.string(d) || is.number(d);\n      });\n    }\n\n    return is.string(item);\n  });\n\n  if (!isValidInput) {\n    throw new TypeError(\"input format isn't supported\");\n  }\n\n  var output = Object.entries(input).map(function (_a) {\n    var _b = __read(_a, 2),\n        key = _b[0],\n        value = _b[1];\n\n    var nextKey = encodeValuesOnly ? key : encoder(key);\n    var nextValue = is.array(value) ? value.map(encoder).join(',') : encoder(\"\".concat(value));\n    return \"\".concat(nextKey, \"=\").concat(nextValue);\n  }).join('&');\n  return \"\".concat(addPrefix ? '?' : '').concat(output);\n}\n/**\n * Parse a query string\n */\n\nexport function queryStringParse(input) {\n  var search = input;\n\n  if (input.slice(0, 1) === '?') {\n    search = input.slice(1);\n  }\n\n  return search.split('&').reduce(function (acc, d) {\n    var _a = __read(d.split('='), 2),\n        key = _a[0],\n        value = _a[1];\n\n    acc[decodeURIComponent(key)] = decodeURIComponent(value);\n    return acc;\n  }, {});\n}\n/**\n * Sort object keys\n */\n\nexport function sortObjectKeys(input) {\n  return Object.keys(input).sort().reduce(function (acc, key) {\n    acc[key] = input[key];\n    return acc;\n  }, {});\n}","map":{"version":3,"mappings":"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","names":["is","cleanUpObject","input","Object","fromEntries","entries","filter","_a","_b","_","v","undefined","includes","getNestedProperty","path","plainObject","array","segments","split","output","index","currentSegment","remainingSegments","slice","length","map","join","invertKeys","TypeError","result","_c","key","value","keyMirror","prototype","hasOwnProperty","call","objectToArray","includeOnly","omit","pick","queryStringFormat","options","encodeValuesOnly","encoder","encodeURIComponent","isValidInput","values","every","item","string","d","number","nextKey","nextValue","concat","addPrefix","queryStringParse","search","reduce","acc","decodeURIComponent","sortObjectKeys","keys","sort"],"sources":["/My_WORK/graduate_React/frontend/node_modules/@gilbarbara/helpers/src/objects.ts"],"sourcesContent":["import { AnyObject, PlainObject } from '@gilbarbara/types';\nimport is from 'is-lite';\n\nimport { InvertKeyValue, QueryStringFormatOptions } from './types';\n\n/**\n * Remove properties with undefined or empty string value from an object\n */\nexport function cleanUpObject<T = AnyObject>(input: PlainObject<T>) {\n  return Object.fromEntries(Object.entries(input).filter(([_, v]) => ![undefined, ''].includes(v)));\n}\n\n/**\n * Get a nested property inside an object or array\n */\nexport function getNestedProperty<T extends AnyObject>(input: T, path: string): any {\n  if ((!is.plainObject(input) && !is.array(input)) || !path) {\n    return input;\n  }\n\n  const segments = path.split('.');\n  const { length } = segments;\n  let output = input;\n\n  for (let index = 0; index < length; index++) {\n    const currentSegment = segments[index];\n    const remainingSegments = segments.slice(index + 1);\n\n    if (currentSegment === '+' && is.array(output) && remainingSegments.length === 1) {\n      return output.map(d => d[remainingSegments.join('.')]);\n    }\n\n    try {\n      output = output[currentSegment] as any;\n    } catch {\n      // skip\n    }\n  }\n\n  return output;\n}\n\n/**\n * Invert object key and value\n */\nexport function invertKeys<T extends AnyObject>(input: PlainObject<T>): InvertKeyValue<T> {\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  const result: any = {};\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const [key, value] of Object.entries(input)) {\n    result[value] = key;\n  }\n\n  return result;\n}\n\n/**\n * Set the key as the value\n */\nexport function keyMirror<T extends AnyObject>(input: PlainObject<T>): { [K in keyof T]: K } {\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  const output: any = {};\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in input) {\n    /* istanbul ignore else */\n    if (!Object.prototype.hasOwnProperty.call(output, key)) {\n      output[key] = key;\n    }\n  }\n\n  return output;\n}\n\n/**\n * Convert an object to an array of objects\n */\nexport function objectToArray<T extends AnyObject>(input: PlainObject<T>, includeOnly?: string) {\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  return Object.entries(input)\n    .filter(([, value]) => (includeOnly ? typeof value === `${includeOnly}` : true)) // eslint-disable-line valid-typeof\n    .map(([key, value]) => ({ [key]: value }));\n}\n\n/**\n * Remove properties from an object\n */\nexport function omit<T extends AnyObject, K extends keyof T>(\n  input: PlainObject<T>,\n  ...filter: K[]\n) {\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  const output: any = {};\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in input) {\n    /* istanbul ignore else */\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key as unknown as K)) {\n        output[key] = input[key];\n      }\n    }\n  }\n\n  return output as Omit<T, K>;\n}\n\n/**\n * Select properties from an object\n */\nexport function pick<T extends AnyObject, K extends keyof T>(\n  input: PlainObject<T>,\n  ...filter: K[]\n) {\n  if (!is.plainObject(input)) {\n    throw new TypeError('Expected an object');\n  }\n\n  if (!filter.length) {\n    return input;\n  }\n\n  const output: any = {};\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in input) {\n    /* istanbul ignore else */\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (filter.includes(key as unknown as K)) {\n        output[key] = input[key];\n      }\n    }\n  }\n\n  return output as Pick<T, K>;\n}\n\n/**\n * Stringify a shallow object into a query string\n */\nexport function queryStringFormat<T extends AnyObject>(\n  input: PlainObject<T>,\n  options: QueryStringFormatOptions = {},\n) {\n  const { addPrefix = false, encodeValuesOnly = true, encoder = encodeURIComponent } = options;\n\n  if (!is.plainObject(input)) {\n    throw new TypeError(\"input type isn't supported\");\n  }\n\n  const isValidInput = Object.values(input).every(item => {\n    if (is.array(item)) {\n      return item.every(d => is.string(d) || is.number(d));\n    }\n\n    return is.string(item);\n  });\n\n  if (!isValidInput) {\n    throw new TypeError(\"input format isn't supported\");\n  }\n\n  const output = Object.entries(input)\n    .map(([key, value]) => {\n      const nextKey = encodeValuesOnly ? key : encoder(key);\n      const nextValue = is.array(value) ? value.map(encoder).join(',') : encoder(`${value}`);\n\n      return `${nextKey}=${nextValue}`;\n    })\n    .join('&');\n\n  return `${addPrefix ? '?' : ''}${output}`;\n}\n\n/**\n * Parse a query string\n */\nexport function queryStringParse(input: string): AnyObject<string> {\n  let search = input;\n\n  if (input.slice(0, 1) === '?') {\n    search = input.slice(1);\n  }\n\n  return search.split('&').reduce<AnyObject<string>>((acc, d) => {\n    const [key, value] = d.split('=');\n\n    acc[decodeURIComponent(key)] = decodeURIComponent(value);\n\n    return acc;\n  }, {});\n}\n\n/**\n * Sort object keys\n */\nexport function sortObjectKeys<T extends AnyObject>(input: PlainObject<T>) {\n  return Object.keys(input)\n    .sort()\n    .reduce((acc, key) => {\n      acc[key] = input[key];\n\n      return acc;\n    }, {} as AnyObject);\n}\n"]},"metadata":{},"sourceType":"module"}